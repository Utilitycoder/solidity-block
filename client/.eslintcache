[{"/Users/tm/blockly_solidity/client/src/index.js":"1","/Users/tm/blockly_solidity/client/src/App.js":"2","/Users/tm/blockly_solidity/client/src/generator/generator.js":"3","/Users/tm/blockly_solidity/client/src/blocks/customblocks.js":"4","/Users/tm/blockly_solidity/client/src/components/Blockly/index.js":"5","/Users/tm/blockly_solidity/client/src/components/Blockly/BlocklyComponent.jsx":"6","/Users/tm/blockly_solidity/client/src/components/Header/header.js":"7","/Users/tm/blockly_solidity/client/src/components/Header/styles.js":"8"},{"size":169,"mtime":1661618468811,"results":"9","hashOfConfig":"10"},{"size":4380,"mtime":1661787912353,"results":"11","hashOfConfig":"10"},{"size":44660,"mtime":1661456958584,"results":"12","hashOfConfig":"10"},{"size":35701,"mtime":1661453539795,"results":"13","hashOfConfig":"10"},{"size":1656,"mtime":1659533452141,"results":"14","hashOfConfig":"10"},{"size":2480,"mtime":1661618586631,"results":"15","hashOfConfig":"10"},{"size":1429,"mtime":1661787795044,"results":"16","hashOfConfig":"10"},{"size":313,"mtime":1661785312386,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"zflhex",{"filePath":"20","messages":"21","errorCount":1,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"22","messages":"23","errorCount":0,"warningCount":33,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"25"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":34,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"25"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"33","messages":"34","errorCount":3,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/tm/blockly_solidity/client/src/index.js",[],"/Users/tm/blockly_solidity/client/src/App.js",["37","38","39","40"],"/Users/tm/blockly_solidity/client/src/generator/generator.js",["41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73"],"import Blockly from \"blockly\";\n\nexport const Solidity = new Blockly.Generator(\"Solidity\");\nconst {NameType} = new Blockly.Names(\"revert,blockhash,keccak256,sha256,ripemd160,ecrecover,addmod,mulmod,this,super,selfdestruct,type\");\n\nconst objectUtils = Blockly.utils.object;\nconst stringUtils = Blockly.utils.string;\n\nSolidity.isInitialized = false;\n\n//incomplete list\nSolidity.addReservedWords(\n  \"after,alias,apply,auto,byte,case,copyof,default,\" +\n    \"define,final,implements,in,inline,let,macro,match,\" +\n    \"mutable,null,of,partial,promise,reference,relocatable,sealed,\",\n  \"sizeof,static,supports,switch,typedef,typeof,var\",\n  \"function,true,false,bool,int8,int,uint8,\",\n  \"uint,address,bytes1,contract,constructor,uint8,\",\n  \"override,virtual,indexed,anonymous,immutable,constant,payable,view,pure,\",\n  \"public,private,external,internal,abi,bytes,block,gasleft,msg,tx,assert,require,\",\n  \"revert,blockhash,keccak256,sha256,ripemd160,ecrecover,addmod,mulmod,this,\",\n  \"super,selfdestruct,type\"\n);\nSolidity.ORDER_ATOMIC = 0; // 0 \"\" ...\nSolidity.ORDER_NEW = 1.1; // new\nSolidity.ORDER_MEMBER = 1.2; // . []\nSolidity.ORDER_FUNCTION_CALL = 2; // ()\nSolidity.ORDER_INCREMENT = 3; // ++\nSolidity.ORDER_DECREMENT = 3; // --\nSolidity.ORDER_BITWISE_NOT = 4.1; // ~\nSolidity.ORDER_UNARY_PLUS = 4.2; // +\nSolidity.ORDER_UNARY_NEGATION = 4.3; // -\nSolidity.ORDER_LOGICAL_NOT = 4.4; // !\nSolidity.ORDER_TYPEOF = 4.5; // typeof\nSolidity.ORDER_VOID = 4.6; // void\nSolidity.ORDER_DELETE = 4.7; // delete\nSolidity.ORDER_DIVISION = 5.1; // /\nSolidity.ORDER_MULTIPLICATION = 5.2; // *\nSolidity.ORDER_MODULUS = 5.3; // %\nSolidity.ORDER_SUBTRACTION = 6.1; // -\nSolidity.ORDER_ADDITION = 6.2; // +\nSolidity.ORDER_BITWISE_SHIFT = 7; // << >> >>>\nSolidity.ORDER_RELATIONAL = 8; // < <= > >=\nSolidity.ORDER_IN = 8; // in\nSolidity.ORDER_INSTANCEOF = 8; // instanceof\nSolidity.ORDER_EQUALITY = 9; // == != === !==\nSolidity.ORDER_BITWISE_AND = 10; // &\nSolidity.ORDER_BITWISE_XOR = 11; // ^\nSolidity.ORDER_BITWISE_OR = 12; // |\nSolidity.ORDER_LOGICAL_AND = 13; // &&\nSolidity.ORDER_LOGICAL_OR = 14; // ||\nSolidity.ORDER_CONDITIONAL = 15; // ?:\nSolidity.ORDER_ASSIGNMENT = 16; // = += -= *= /= %= <<= >>= ...\nSolidity.ORDER_COMMA = 17; // ,\nSolidity.ORDER_NONE = 99; // (...)\n\n/**\n * List of outer-inner pairings that do NOT require parentheses.\n * @type {!Array<!Array<number>>}\n */\nSolidity.ORDER_OVERRIDES = [\n  // (foo()).bar -> foo().bar\n  // (foo())[0] -> foo()[0]\n  [Solidity.ORDER_FUNCTION_CALL, Solidity.ORDER_MEMBER],\n  // (foo())() -> foo()()\n  [Solidity.ORDER_FUNCTION_CALL, Solidity.ORDER_FUNCTION_CALL],\n  // (foo.bar).baz -> foo.bar.baz\n  // (foo.bar)[0] -> foo.bar[0]\n  // (foo[0]).bar -> foo[0].bar\n  // (foo[0])[1] -> foo[0][1]\n  [Solidity.ORDER_MEMBER, Solidity.ORDER_MEMBER],\n  // (foo.bar)() -> foo.bar()\n  // (foo[0])() -> foo[0]()\n  [Solidity.ORDER_MEMBER, Solidity.ORDER_FUNCTION_CALL],\n\n  // !(!foo) -> !!foo\n  [Solidity.ORDER_LOGICAL_NOT, Solidity.ORDER_LOGICAL_NOT],\n  // a * (b * c) -> a * b * c\n  [Solidity.ORDER_MULTIPLICATION, Solidity.ORDER_MULTIPLICATION],\n  // a + (b + c) -> a + b + c\n  [Solidity.ORDER_ADDITION, Solidity.ORDER_ADDITION],\n  // a && (b && c) -> a && b && c\n  [Solidity.ORDER_LOGICAL_AND, Solidity.ORDER_LOGICAL_AND],\n  // a || (b || c) -> a || b || c\n  [Solidity.ORDER_LOGICAL_OR, Solidity.ORDER_LOGICAL_OR],\n];\n\n/**\n * Whether the init method has been called.\n * @type {?boolean}\n */\nSolidity.isInitialized = false;\n\n/**\n * Initialise the database of variable names.\n * @param {!Workspace} workspace Workspace to generate code from.\n */\nSolidity.init = function (workspace) {\n  // Call Blockly.Generator's init.\n  Object.getPrototypeOf(this).init.call(this);\n\n  if (!this.nameDB_) {\n    this.nameDB_ = new Blockly.Names(this.RESERVED_WORDS_);\n  } else {\n    this.nameDB_.reset();\n  }\n  this.nameDB_.setVariableMap(workspace.getVariableMap());\n  this.nameDB_.populateVariables(workspace);\n  this.nameDB_.populateProcedures(workspace);\n\n  this.isInitialized = true;\n};\n\n/**\n * Prepend the generated code with the variable definitions.\n * @param {string} code Generated code.\n * @return {string} Completed code.\n */\nSolidity.finish = function (code) {\n  // Convert the definitions dictionary into a list.\n  const definitions = objectUtils.values(this.definitions_);\n  // Call Blockly.Generator's finish.\n  code = Object.getPrototypeOf(this).finish.call(this, code);\n  this.isInitialized = false;\n\n  this.nameDB_.reset();\n\n  return definitions.join(\"\\n\\n\") + \"\\n\\n\\n\" + code;\n};\n\n/**\n * Naked values are top-level blocks with outputs that aren't plugged into\n * anything.  A trailing semicolon is needed to make this legal.\n * @param {string} line Line of generated code.\n * @return {string} Legal line of code.\n */\nSolidity.scrubNakedValue = function (line) {\n  return line + \";\\n\";\n};\n\n/**\n * Encode a string as a properly escaped Solidity string, complete with\n * quotes.\n * @param {string} string Text to encode.\n * @return {string} Solidity string.\n * @protected\n */\nSolidity.quote_ = function (string) {\n  // Can't use goog.string.quote since Google's style guide recommends\n  // JS string literals use single quotes.\n  string = string\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\\n/g, \"\\\\\\n\")\n    .replace(/'/g, \"\\\\'\");\n  return \"'\" + string + \"'\";\n};\n\n/**\n * Encode a string as a properly escaped multiline Solidity string, complete\n * with quotes.\n * @param {string} string Text to encode.\n * @return {string} Solidity string.\n * @protected\n */\nSolidity.multiline_quote_ = function (string) {\n  // Can't use goog.string.quote since Google's style guide recommends\n  // JS string literals use single quotes.\n  const lines = string.split(/\\n/g).map(this.quote_);\n  return lines.join(\" + '\\\\n' +\\n\");\n};\n\n/**\n * Common tasks for generating Solidity from blocks.\n * Handles comments for the specified block and any connected value blocks.\n * Calls any statements following this block.\n * @param {!Block} block The current block.\n * @param {string} code The Solidity code created for this block.\n * @param {boolean=} opt_thisOnly True to generate code for only this statement.\n * @return {string} Solidity code with comments and subsequent blocks added.\n * @protected\n */\nSolidity.scrub_ = function (block, code) {\n  var commentCode = \"\";\n  // Only collect comments for blocks that aren't inline.\n  if (!block.outputConnection || !block.outputConnection.targetConnection) {\n    // Collect comment for this block.\n    var comment = block.getCommentText();\n    comment = Blockly.utils.wrap\n      ? Blockly.utils.wrap(comment, Solidity.COMMENT_WRAP - 3)\n      : \"\";\n    if (comment) {\n      if (block.getProcedureDef) {\n        // Use a comment block for function comments.\n        commentCode +=\n          \"/**\\n\" + Solidity.prefixLines(comment + \"\\n\", \" * \") + \" */\\n\";\n      } else {\n        commentCode += Solidity.prefixLines(comment + \"\\n\", \"// \");\n      }\n    }\n    // Collect comments for all value arguments.\n    // Don't collect comments for nested statements.\n    for (var i = 0; i < block.inputList.length; i++) {\n      if (block.inputList[i].type == Blockly.INPUT_VALUE) {\n        var childBlock = block.inputList[i].connection.targetBlock();\n        if (childBlock) {\n          var comment = Solidity.allNestedComments(childBlock);\n          if (comment) {\n            commentCode += Solidity.prefixLines(comment, \"// \");\n          }\n        }\n      }\n    }\n  }\n  var nextBlock = block.nextConnection && block.nextConnection.targetBlock();\n  var nextCode = Solidity.blockToCode(nextBlock);\n  return commentCode + code + nextCode;\n};\n\n/**\n * Gets a property and adjusts the value while taking into account indexing.\n * @param {!Block} block The block.\n * @param {string} atId The property ID of the element to get.\n * @param {number=} opt_delta Value to add.\n * @param {boolean=} opt_negate Whether to negate the value.\n * @param {number=} opt_order The highest order acting on this value.\n * @return {string|number}\n */\nSolidity.getAdjusted = function (\n  block,\n  atId,\n  opt_delta,\n  opt_negate,\n  opt_order\n) {\n  let delta = opt_delta || 0;\n  let order = opt_order || this.ORDER_NONE;\n  if (block.workspace.options.oneBasedIndex) {\n    delta--;\n  }\n  const defaultAtIndex = block.workspace.options.oneBasedIndex ? \"1\" : \"0\";\n\n  let innerOrder;\n  let outerOrder = order;\n  if (delta > 0) {\n    outerOrder = this.ORDER_ADDITION;\n    innerOrder = this.ORDER_ADDITION;\n  } else if (delta < 0) {\n    outerOrder = this.ORDER_SUBTRACTION;\n    innerOrder = this.ORDER_SUBTRACTION;\n  } else if (opt_negate) {\n    outerOrder = this.ORDER_UNARY_NEGATION;\n    innerOrder = this.ORDER_UNARY_NEGATION;\n  }\n\n  let at = this.valueToCode(block, atId, outerOrder) || defaultAtIndex;\n\n  if (stringUtils.isNumber(at)) {\n    // If the index is a naked number, adjust it right now.\n    at = Number(at) + delta;\n    if (opt_negate) {\n      at = -at;\n    }\n  } else {\n    // If the index is dynamic, adjust it in code.\n    if (delta > 0) {\n      at = at + \" + \" + delta;\n    } else if (delta < 0) {\n      at = at + \" - \" + -delta;\n    }\n    if (opt_negate) {\n      if (delta) {\n        at = \"-(\" + at + \")\";\n      } else {\n        at = \"-\" + at;\n      }\n    }\n    innerOrder = Math.floor(innerOrder);\n    order = Math.floor(order);\n    if (innerOrder && order >= innerOrder) {\n      at = \"(\" + at + \")\";\n    }\n  }\n  return at;\n};\n\nSolidity.updateWorkspaceNameFields = function (workspace) {\n  var blocks = workspace.getAllBlocks();\n  for (var i = 0; i < blocks.length; ++i) {\n    var nameField = blocks[i].getVariableNameSelectField\n      ? blocks[i].getVariableNameSelectField()\n      : null;\n    var group = blocks[i].getVariableLabelGroup\n      ? blocks[i].getVariableLabelGroup()\n      : null;\n\n    if (!!nameField && !!group) {\n      var vars = Solidity.getVariablesInScope(blocks[i], group);\n      var options = vars.map(function (v) {\n        return [Solidity.getVariableName(v), v.id_];\n      });\n\n      var selectedOption = nameField.getValue();\n\n      if (options.length != 0) {\n        var wasUndefined =\n          nameField.menuGenerator_[0][1] == Solidity.UNDEFINED_NAME;\n\n        nameField.menuGenerator_ = options;\n        if (wasUndefined) {\n          nameField.setValue(options[0][1]);\n        } else {\n          nameField.setValue(selectedOption);\n          // The text input does not redraw/update itself after we call \"setValue\",\n          // so we set the text manually.\n          // nameField.setText(\n          //   options.filter(function (o) { return o[1] == selectedOption })[0][0]\n          // );\n        }\n      }\n    }\n  }\n};\n\nSolidity.updateWorkspaceTypes = function (\n  workspace,\n  nameFieldName,\n  valueFieldName\n) {\n  var blocks = workspace.getAllBlocks();\n  var vars = workspace.getAllVariables();\n\n  for (var i = 0; i < blocks.length; ++i) {\n    var stateNameField = blocks[i].getField(nameFieldName);\n\n    if (!stateNameField) {\n      continue;\n    }\n\n    var variableId = blocks[i].getFieldValue(nameFieldName);\n    var variable = workspace.getVariableById(variableId);\n\n    if (!variable) {\n      return;\n    }\n\n    if (\n      blocks[i].inputList[0] &&\n      blocks[i].inputList[0].name == valueFieldName\n    ) {\n      switch (variable.type) {\n        case \"TYPE_BOOL\":\n          blocks[i].inputList[0].setCheck(\"Boolean\");\n          break;\n        case \"TYPE_INT\":\n          blocks[i].inputList[0].setCheck(\"Number\");\n          break;\n        case \"TYPE_UINT\":\n          blocks[i].inputList[0].setCheck(\"Number\");\n          break;\n        case \"TYPE_STRING\":\n          blocks[i].inputList[0].setCheck(\"String\");\n          break;\n        case \"TYPE_ADDRESS\":\n          blocks[i].inputList[0].setCheck(\"String\");\n          break;\n        default:\n      }\n    }\n    // TODO: update the output type\n  }\n};\n\nSolidity.updateWorkspaceStateTypes = function (workspace) {\n  Solidity.updateWorkspaceTypes(workspace, \"STATE_NAME\", \"STATE_VALUE\");\n};\n\nSolidity.updateWorkspaceParameterTypes = function (workspace) {\n  Solidity.updateWorkspaceTypes(workspace, \"PARAM_NAME\", \"PARAM_VALUE\");\n};\n\nSolidity.createVariable = function (workspace, group, type, name, scope, id) {\n  var variable = workspace.createVariable(name, type, id);\n\n  variable.group = group;\n  variable.scope = scope;\n\n  Solidity.setVariableName(variable, name);\n\n  return variable;\n};\n\nSolidity.getVariableById = function (workspace, id) {\n  return workspace.getVariableById(id);\n};\n\nSolidity.getVariableByName = function (workspace, name) {\n  return Solidity.getAllVariables(workspace).filter(function (v) {\n    return Solidity.getVariableName(v) == name;\n  })[0];\n};\n\nSolidity.getVariableByNameAndScope = function (name, scope, group = null) {\n  return Solidity.getVariablesInScope(scope, group).filter(function (v) {\n    return Solidity.getVariableName(v) == name;\n  })[0];\n};\n\nSolidity.deleteVariableById = function (workspace, id) {\n  Solidity.deleteVariableByName(\n    workspace,\n    Solidity.getVariableById(workspace, id).name\n  );\n};\n\nSolidity.deleteVariableByName = function (workspace, name) {\n  return workspace.deleteVariable(name);\n};\n\nSolidity.variableIsInScope = function (variable, scope) {\n  while (!!scope && scope.id != variable.scope.id) {\n    var type = scope.type;\n    do {\n      scope = scope.getParent();\n    } while (scope && type == scope.type);\n  }\n\n  return !!scope;\n};\n\nSolidity.setVariableName = function (variable, name) {\n  variable.name = '_scope(\"' + variable.scope.id + '\")_' + name;\n};\n\nSolidity.getVariableName = function (variable) {\n  return variable.name.replace('_scope(\"' + variable.scope.id + '\")_', \"\");\n};\n\nSolidity.getAllVariables = function (workspace) {\n  return workspace.getAllVariables();\n};\n\nSolidity.getVariablesInScope = function (block, group = null) {\n  return Solidity.getAllVariables(block.workspace)\n    .filter(function (v) {\n      return Solidity.variableIsInScope(v, block);\n    })\n    .filter(function (v) {\n      return !group || v.group == group;\n    });\n};\n\nSolidity[\"contract\"] = function (block) {\n  var states = Solidity.statementToCode(block, \"STATES\");\n  if (states.length > 0) {\n    states += \"\\n\";\n  }\n  var ctor = Solidity.statementToCode(block, \"CTOR\");\n  var methods = Solidity.statementToCode(block, \"METHODS\");\n\n  // trim newline before ultimate closing curly brace\n  if (methods.length > 0) {\n    methods = methods.slice(0, -2);\n  } else if (ctor.length > 0) {\n    ctor = ctor.slice(0, -2);\n  }\n\n  var code =\n    \"//SPDX-License-Identifier: MIT\\n\\n\" +\n    \"pragma solidity ^0.8.17;\\n\\n\" +\n    \"contract \" +\n    block.getFieldValue(\"NAME\") +\n    \" {\\n\\n\" +\n    states +\n    ctor +\n    methods +\n    \"}\\n\";\n\n  return code;\n};\n\nSolidity[\"contract_state\"] = function (block) {\n  var name = block.getFieldValue(\"NAME\");\n  var value = Solidity.valueToCode(block, \"VALUE\", Solidity.ORDER_ASSIGNMENT);\n  var type = block.getFieldValue(\"TYPE\");\n  var types = {\n    'TYPE_BOOL': \"bool\",\n    'TYPE_INT': \"int\",\n    'TYPE_UINT': \"uint\",\n    'TYPE_STRING': \"string\",\n    'TYPE_ADDRESS': \"address\",\n  };\n  var defaultValue = {\n    'TYPE_BOOL': \"false\",\n    'TYPE_INT': \"0\",\n    'TYPE_UINT': \"0\",\n    'TYPE_STRING': '\"\"',\n    'TYPE_ADDRESS': \"0x0000000000000000000000000000000000000000\",\n  };\n\n  if (value === \"\") {\n    value = defaultValue[type];\n  }\n\n  return types[type] + \" \" + name + \" = \" + value + \";\\n\";\n};\n\nSolidity[\"contract_state_get\"] = function (block) {\n  var variableId = block.getFieldValue(\"STATE_NAME\");\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n  return [Solidity.getVariableName(variable), Solidity.ORDER_ATOMIC];\n};\n\nSolidity[\"contract_state_set\"] = function (block) {\n  // Variable setter.\n  var argument0 =\n    Solidity.valueToCode(\n      block,\n      \"STATE_VALUE\",\n      Solidity.ORDER_ASSIGNMENT\n    ) || \"0\";\n  var variableId = block.getFieldValue(\"STATE_NAME\");\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n  return Solidity.getVariableName(variable) + \" = \" + argument0 + \";\\n\";\n};\n\nSolidity[\"contract_local_get\"] = function (block) {\n  var variableId = block.getFieldValue(\"LOCAL_NAME\");\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n  return [Solidity.getVariableName(variable), Solidity.ORDER_ATOMIC];\n};\n\nSolidity['state'] = function(block) {\n  var state_variables = block.getFieldValue('state_variables');\n  var visibility = block.getFieldValue('visibility');\n  var state_name = block.getFieldValue('NAME');\n  var value_state = Solidity.valueToCode(block, 'state', Solidity.ORDER_ASSIGNMENT);\n  let state_value\n  if (!value_state) {\n    state_value = \"\"\n  } else {\n    state_value = ` = ${value_state}`\n  }\n  var code = `${state_variables} ${visibility} ${state_name}${state_value};\\n`;\n  return code;\n};\n\n\nSolidity[\"contract_method\"] = function (block) {\n  const params = Solidity.statementToCode(block, \"PARAMS\").trim();\n  const branch = Solidity.statementToCode(block, \"STACK\");\n  const stateChange = block.getFieldValue(\"STATE_CHANGE\")\n  const changeState = stateChange == \"none\" ? \"\" : stateChange\n  const functionReturns = block.getFieldValue(\"Function_Ouput\")\n  const returnsName = block.getFieldValue(\"Variable_name\")\n  const returnFunction = functionReturns == \"none\" ? \"\" : `returns (${functionReturns} ${returnsName})`\n  var code = `function ${block.getFieldValue(\"NAME\")}(${params}) ${block.getFieldValue(\"ACCESS\")} ${changeState} ${returnFunction} {\\n${branch}\\n}\\n\\n`;\n\n  return code;\n};\n\nSolidity[\"contract_ctor\"] = function (block) {\n  var parent = block.getSurroundParent();\n\n  if (!parent) {\n    return \"\";\n  }\n\n  var params = Solidity.statementToCode(block, \"PARAMS\").trim();\n  var branch = Solidity.statementToCode(block, \"STACK\");\n  var code = \"constructor \" + \"(\" + params + \") {\\n\" + branch + \"}\\n\\n\";\n\n  return code;\n};\n\nSolidity[\"contract_method_parameter_memory\"] = function (block) {\n  var name = block.getFieldValue(\"NAME\");\n  var nextBlock = block.getNextBlock();\n  var sep = nextBlock ? \", \" : \"\";\n  var types = {\n    TYPE_BOOL: \"bool\",\n    TYPE_INT: \"int\",\n    TYPE_UINT: \"uint\",\n    TYPE_STRING: \"string\",\n    TYPE_ADDRESS: \"address\",\n  };\n\n  return `${types[block.getFieldValue(\"TYPE\")]} memory ${name}${sep}`;\n};\n\nSolidity[\"contract_method_parameter\"] = function (block) {\n  var name = block.getFieldValue(\"NAME\");\n  var nextBlock = block.getNextBlock();\n  var sep = nextBlock ? \", \" : \"\";\n  var types = {\n    TYPE_BOOL: \"bool\",\n    TYPE_INT: \"int\",\n    TYPE_UINT: \"uint\",\n    TYPE_STRING: \"string\",\n    TYPE_ADDRESS: \"address\",\n  };\n\n  return `${types[block.getFieldValue(\"TYPE\")]} ${name}${sep}`;\n};\n\nSolidity[\"contract_method_parameter_get\"] = function (block) {\n  const inputValue = Solidity.valueToCode(block, 'method_get', Solidity.ORDER_ATOMIC)\n  const setValue = block.getInputTargetBlock(\"method_get\")\n  const inp = setValue == null ? \"\" : \", \"\n  var variableId = block.getFieldValue(\"PARAM_NAME\");\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n  return [`${Solidity.getVariableName(variable)}${inp}${inputValue}`, Solidity.ORDER_ATOMIC];\n};\n\n\nSolidity[\"contract_method_call\"] = function (block) {\n  const value = Solidity.valueToCode(block, 'call_method', Solidity.ORDER_ASSIGNMENT);\n  var variableId = block.getFieldValue(\"METHOD_NAME\");\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n  return `${Solidity.getVariableName(variable)}(${value});\\n`;\n};\n\nSolidity['method_argument'] = function(block) {\n  var text_name = block.getFieldValue('NAME');\n  var value_method_argument = Solidity.valueToCode(block, 'method_argument', Solidity.ORDER_ATOMIC);\n  const inputBlock = block.getInputTargetBlock(\"method_argument\")\n  const inp = inputBlock == null ? \"\" : \", \"\n  var code = `${text_name}${inp}${value_method_argument}`;\n  \n  return [code, Solidity.ORDER_ATOMIC];\n};\n\n\n// Mapping Generated Code\nSolidity['mapping'] = function(block) {\n  const key = Solidity.valueToCode(block, 'key', Solidity.ORDER_ASSIGNMENT);\n  const value = Solidity.valueToCode(block, 'value', Solidity.ORDER_ASSIGNMENT);\n  const dropdown_visibility = block.getFieldValue('visibility');\n  const text_name = block.getFieldValue('NAME');\n  const code = `mapping(${key} => ${value}) ${dropdown_visibility} ${text_name};\\n`;\n  return code;\n};\n\nSolidity['mapping_get'] = function(block) {\n  var dropdown_mapping_name = block.getFieldValue('MAPPING_NAME');\n  var value_mapping_name = Solidity.valueToCode(block, 'mapping_name', Solidity.ORDER_ATOMIC) || \"0\";\n  var dropdown_compare = block.getFieldValue('compare');\n  var value_compare = Solidity.valueToCode(block, 'compare', Solidity.ORDER_ASSIGNMENT) || \"0\";\n\n  var variableId = dropdown_mapping_name;\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n\n  const code = `${Solidity.getVariableName(variable)}[${value_mapping_name}] ${dropdown_compare} ${value_compare}`;\n\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\nSolidity[\"mapping_set\"] = function (block) {\n  // Variable setter.\n  var argument0 =\n    Solidity.valueToCode(block, \"mapping_name\", Solidity.ORDER_ASSIGNMENT) ||\n    \"0\";\n  var argument1 = Solidity.valueToCode(block, 'NAME', Solidity.ORDER_ASSIGNMENT);\n  const setMapping = block.getFieldValue(\"compare\")\n  var variableId = block.getFieldValue(\"MAPPING_NAME\");\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n  return `${Solidity.getVariableName(variable)}[${argument0}] ${setMapping} ${argument1};\\n`;\n};\n\nSolidity['nested_mapping'] = function(block) {\n  const firstKey = Solidity.valueToCode(block, 'firstKey', Solidity.ORDER_ASSIGNMENT);\n  const secondKey = Solidity.valueToCode(block, 'secondKey', Solidity.ORDER_ASSIGNMENT);\n  const value = Solidity.valueToCode(block, 'value', Solidity.ORDER_ASSIGNMENT);\n  const dropdown_visibility = block.getFieldValue('visibility');\n  const text_name = block.getFieldValue('NAME');\n  const code = `mapping(${firstKey} => mapping(${secondKey} => ${value})) ${dropdown_visibility} ${text_name};\\n`;\n  return code;\n};\n\nSolidity[\"nested_mapping_set\"] = function (block) {\n  // Variable setter.\n  var argument0 =\n    Solidity.valueToCode(block, \"nested_mapping_name\", Solidity.ORDER_ASSIGNMENT) ||\n    \"0\";\n  var argument1 = Solidity.valueToCode(block, 'NAME', Solidity.ORDER_ASSIGNMENT);\n  var argument2 = Solidity.valueToCode(block, 'map_value', Solidity.ORDER_ASSIGNMENT);\n  const setMapping = block.getFieldValue(\"compare\")\n  var variableId = block.getFieldValue(\"NESTED_MAPPING_NAME\");\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n  return `${Solidity.getVariableName(variable)}[${argument0}][${argument2}] ${setMapping} ${argument1};\\n`;\n};\n\nSolidity['nested_mapping_get'] = function(block) {\n  var nested_mapping_name = block.getFieldValue('NESTED_MAPPING_NAME');\n  var value_mapping_name = Solidity.valueToCode(block, 'mapping_name', Solidity.ORDER_ATOMIC) || \"0\";\n  var value_name = Solidity.valueToCode(block, 'NAME', Solidity.ORDER_ATOMIC) || \"0\";\n  var dropdown_compare = block.getFieldValue('compare');\n  var value_compare = Solidity.valueToCode(block, 'compare', Solidity.ORDER_ASSIGNMENT) || \"0\";\n\n  var variableId = nested_mapping_name;\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n\n  const code = `${Solidity.getVariableName(variable)}[${value_mapping_name}][${value_name}] ${dropdown_compare} ${value_compare}`;\n\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\n\nSolidity['input'] = function(block) {\n  var code = block.getFieldValue('NAME');\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\nSolidity['event'] = function(block) {\n  var text_name = block.getFieldValue('NAME');\n  var value_event = Solidity.valueToCode(block, 'event', Solidity.ORDER_ATOMIC).trim();\n  // TODO: Assemble JavaScript into code variable.\n  var code = `event ${text_name}(${value_event});\\n`;\n  return code;\n};\n\nSolidity['event_get'] = function(block) {\n  const variableId = block.getFieldValue('EVENT_NAME');\n  var value_mapping_name = Solidity.valueToCode(block, 'event_name', Solidity.ORDER_ATOMIC) || \"0\";\n\n  var variable = block.workspace.getVariableById(variableId);\n\n  if (!variable) {\n    return \"\";\n  }\n\n\n  const code = `emit ${Solidity.getVariableName(variable)}(${value_mapping_name});\\n`;\n\n  return code;\n};\n\nSolidity['event_parameter'] = function(block) {\n  var dropdown_type = block.getFieldValue('type');\n  var text_name = block.getFieldValue('NAME');\n  var event_parameter = Solidity.valueToCode(block, 'event_parameter', Solidity.ORDER_ATOMIC);\n\n  var code = `${dropdown_type} indexed ${text_name}, ${event_parameter}`;\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\n\nSolidity['event_param_nonindex'] = function(block) {\n  var dropdown_type = block.getFieldValue('type');\n  var text_name = block.getFieldValue('NAME');\n  var event_parameter = Solidity.valueToCode(block, 'event_parameter', Solidity.ORDER_ATOMIC);\n  var code = `${dropdown_type} ${text_name} ${event_parameter}`;\n  // TODO: Change ORDER_NONE to the correct strength.\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\nSolidity['space'] = function(block) {\n  // TODO: Assemble JavaScript into code variable.\n  var code = `\\n`;\n  return code;\n};\n\n\n// Error-Handling\nSolidity['require'] = function(block) {\n  var value_require = Solidity.valueToCode(block, 'require', Solidity.ORDER_ATOMIC);\n  // TODO: Assemble JavaScript into code variable.\n  var code =`require(${value_require});\\n`;\n  return code;\n};\n\nSolidity['boolean'] = function(block) {\n  var dropdown_boolean = block.getFieldValue('boolean');\n  var code = dropdown_boolean;\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\nSolidity['returns'] = function(block) {\n  var value_name = Solidity.valueToCode(block, 'NAME', Solidity.ORDER_ATOMIC);\n  const code = `return ${value_name};\\n`;\n  return code;\n};\n\n// Solidity['requre'] = function(block) {\n//   var value_name = Solidity.valueToCode(block, 'NAME', Solidity.ORDER_ATOMIC);\n//   var value_error = Solidity.valueToCode(block, 'error', Solidity.ORDER_ATOMIC);\n//   // TODO: Assemble JavaScript into code variable.\n//   var code = '...;\\n';\n//   return code;\n// };\n\nSolidity[\"controls_if\"] = function (block) {\n  // If/elseif/else condition.\n  var n = 0;\n  var code = \"\",\n    branchCode,\n    conditionCode;\n  do {\n    conditionCode =\n      Solidity.valueToCode(block, \"IF\" + n, Solidity.ORDER_NONE) || \"false\";\n    branchCode = Solidity.statementToCode(block, \"DO\" + n);\n    code +=\n      (n > 0 ? \" else \" : \"\") +\n      \"if (\" +\n      conditionCode +\n      \") {\\n\" +\n      branchCode +\n      \"}\";\n\n    ++n;\n  } while (block.getInput(\"IF\" + n));\n\n  if (block.getInput(\"ELSE\")) {\n    branchCode = Solidity.statementToCode(block, \"ELSE\");\n    code += \" else {\\n\" + branchCode + \"}\";\n  }\n  return code + \"\\n\";\n};\n\nSolidity[\"controls_ifelse\"] = Solidity[\"controls_if\"];\n\nSolidity[\"logic_compare\"] = function (block) {\n  // Comparison operator.\n  var OPERATORS = {\n    EQ: \"==\",\n    NEQ: \"!=\",\n    LT: \"<\",\n    LTE: \"<=\",\n    GT: \">\",\n    GTE: \">=\",\n  };\n  var operator = OPERATORS[block.getFieldValue(\"OP\")];\n  // var order =\n  //   operator == \"==\" || operator == \"!=\"\n  //     ? Solidity.ORDER_EQUALITY\n  //     : Solidity.ORDER_RELATIONAL;\n  var argument0 = Solidity.valueToCode(block, \"A\", Solidity.ORDER_ATOMIC) || \"0\";\n  var argument1 = Solidity.valueToCode(block, \"B\", Solidity.ORDER_ATOMIC) || \"0\";\n  var code = `${argument0} ${operator} ${argument1}`;\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\nSolidity[\"logic_operation\"] = function (block) {\n  // Operations 'and', 'or'.\n  var operator = block.getFieldValue(\"OP\") == \"AND\" ? \"&&\" : \"||\";\n  var order =\n    operator == \"&&\" ? Solidity.ORDER_LOGICAL_AND : Solidity.ORDER_LOGICAL_OR;\n  var argument0 = Solidity.valueToCode(block, \"A\", order);\n  var argument1 = Solidity.valueToCode(block, \"B\", order);\n  if (!argument0 && !argument1) {\n    // If there are no arguments, then the return value is false.\n    argument0 = \"false\";\n    argument1 = \"false\";\n  } else {\n    // Single missing arguments have no effect on the return value.\n    var defaultArgument = operator == \"&&\" ? \"true\" : \"false\";\n    if (!argument0) {\n      argument0 = defaultArgument;\n    }\n    if (!argument1) {\n      argument1 = defaultArgument;\n    }\n  }\n  var code = argument0 + \" \" + operator + \" \" + argument1;\n  return [code, order];\n};\n\nSolidity[\"logic_negate\"] = function (block) {\n  // Negation.\n  var order = Solidity.ORDER_LOGICAL_NOT;\n  var argument0 = Solidity.valueToCode(block, \"BOOL\", order) || \"true\";\n  var code = \"!\" + argument0;\n  return [code, order];\n};\n\nSolidity[\"logic_null\"] = function (block) {\n  // Null data type.\n  return [\"null\", Solidity.ORDER_ATOMIC];\n};\n\nSolidity[\"logic_ternary\"] = function (block) {\n  // Ternary operator.\n  var value_if =\n    Solidity.valueToCode(block, \"IF\", Solidity.ORDER_CONDITIONAL) || \"false\";\n  var value_then =\n    Solidity.valueToCode(block, \"THEN\", Solidity.ORDER_CONDITIONAL) || \"null\";\n  var value_else =\n    Solidity.valueToCode(block, \"ELSE\", Solidity.ORDER_CONDITIONAL) || \"null\";\n  var code = value_if + \" ? \" + value_then + \" : \" + value_else;\n  return [code, Solidity.ORDER_CONDITIONAL];\n};\n\nSolidity[\"math_number\"] = function (block) {\n  // Numeric value.\n  var code = parseFloat(block.getFieldValue(\"NUM\"));\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\nSolidity[\"math_arithmetic\"] = function (block) {\n  // Basic arithmetic operators, and power.\n  var OPERATORS = {\n    ADD: [\" + \", Solidity.ORDER_ADDITION],\n    MINUS: [\" - \", Solidity.ORDER_SUBTRACTION],\n    MULTIPLY: [\" * \", Solidity.ORDER_MULTIPLICATION],\n    DIVIDE: [\" / \", Solidity.ORDER_DIVISION],\n    POWER: [\" ** \", Solidity.ORDER_EXPONENTATION],\n  };\n  var tuple = OPERATORS[block.getFieldValue(\"OP\")];\n  var operator = tuple[0];\n  var order = tuple[1];\n  var argument0 = Solidity.valueToCode(block, \"A\", order) || \"0\";\n  var argument1 = Solidity.valueToCode(block, \"B\", order) || \"0\";\n  var code = argument0 + operator + argument1;\n  return [code, order];\n};\n\nSolidity[\"math_single\"] = function (block) {\n  // Math operators with single operand.\n  var operator = block.getFieldValue(\"OP\");\n  var code;\n  var arg;\n  if (operator == \"NEG\") {\n    // Negation is a special case given its different operator precedence.\n    arg =\n      Solidity.valueToCode(block, \"NUM\", Solidity.ORDER_UNARY_NEGATION) || \"0\";\n    if (arg[0] == \"-\") {\n      // --3 is not legal in JS.\n      arg = \" \" + arg;\n    }\n    code = \"-\" + arg;\n    return [code, Solidity.ORDER_UNARY_NEGATION];\n  }\n  if (operator == \"SIN\" || operator == \"COS\" || operator == \"TAN\") {\n    arg = Solidity.valueToCode(block, \"NUM\", Solidity.ORDER_DIVISION) || \"0\";\n  } else {\n    arg = Solidity.valueToCode(block, \"NUM\", Solidity.ORDER_NONE) || \"0\";\n  }\n  // First, handle cases which generate values that don't need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case \"ABS\":\n      code = \"Math.abs(\" + arg + \")\";\n      break;\n    case \"ROOT\":\n      code = \"Math.sqrt(\" + arg + \")\";\n      break;\n    case \"LN\":\n      code = \"Math.log(\" + arg + \")\";\n      break;\n    case \"EXP\":\n      code = \"Math.exp(\" + arg + \")\";\n      break;\n    case \"POW10\":\n      code = \"Math.pow(10,\" + arg + \")\";\n      break;\n    case \"ROUND\":\n      code = \"Math.round(\" + arg + \")\";\n      break;\n    case \"ROUNDUP\":\n      code = \"Math.ceil(\" + arg + \")\";\n      break;\n    case \"ROUNDDOWN\":\n      code = \"Math.floor(\" + arg + \")\";\n      break;\n    case \"SIN\":\n      code = \"Math.sin(\" + arg + \" / 180 * Math.PI)\";\n      break;\n    case \"COS\":\n      code = \"Math.cos(\" + arg + \" / 180 * Math.PI)\";\n      break;\n    case \"TAN\":\n      code = \"Math.tan(\" + arg + \" / 180 * Math.PI)\";\n      break;\n  }\n  if (code) {\n    return [code, Solidity.ORDER_FUNCTION_CALL];\n  }\n  // Second, handle cases which generate values that may need parentheses\n  // wrapping the code.\n  switch (operator) {\n    case \"LOG10\":\n      code = \"Math.log(\" + arg + \") / Math.log(10)\";\n      break;\n    case \"ASIN\":\n      code = \"Math.asin(\" + arg + \") / Math.PI * 180\";\n      break;\n    case \"ACOS\":\n      code = \"Math.acos(\" + arg + \") / Math.PI * 180\";\n      break;\n    case \"ATAN\":\n      code = \"Math.atan(\" + arg + \") / Math.PI * 180\";\n      break;\n    default:\n      throw \"Unknown math operator: \" + operator;\n  }\n  return [code, Solidity.ORDER_DIVISION];\n};\n\nSolidity[\"math_constant\"] = function (block) {\n  // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n  var CONSTANTS = {\n    PI: [\"Math.PI\", Solidity.ORDER_MEMBER],\n    E: [\"Math.E\", Solidity.ORDER_MEMBER],\n    GOLDEN_RATIO: [\"(1 + Math.sqrt(5)) / 2\", Solidity.ORDER_DIVISION],\n    SQRT2: [\"Math.SQRT2\", Solidity.ORDER_MEMBER],\n    SQRT1_2: [\"Math.SQRT1_2\", Solidity.ORDER_MEMBER],\n    INFINITY: [\"Infinity\", Solidity.ORDER_ATOMIC],\n  };\n  return CONSTANTS[block.getFieldValue(\"CONSTANT\")];\n};\n\nSolidity[\"math_number_property\"] = function (block) {\n  // Check if a number is even, odd, prime, whole, positive, or negative\n  // or if it is divisible by certain number. Returns true or false.\n  var number_to_check =\n    Solidity.valueToCode(block, \"NUMBER_TO_CHECK\", Solidity.ORDER_MODULUS) ||\n    \"0\";\n  var dropdown_property = block.getFieldValue(\"PROPERTY\");\n  var code;\n  if (dropdown_property == \"PRIME\") {\n    // Prime is a special case as it is not a one-liner test.\n    var functionName = Solidity.provideFunction_(\"mathIsPrime\", [\n      \"function \" + Solidity.FUNCTION_NAME_PLACEHOLDER_ + \"(n) {\",\n      \"  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\",\n      \"  if (n == 2 || n == 3) {\",\n      \"    return true;\",\n      \"  }\",\n      \"  // False if n is NaN, negative, is 1, or not whole.\",\n      \"  // And false if n is divisible by 2 or 3.\",\n      \"  if (isNaN(n) || n <= 1 || n % 1 != 0 || n % 2 == 0 ||\" +\n        \" n % 3 == 0) {\",\n      \"    return false;\",\n      \"  }\",\n      \"  // Check all the numbers of form 6k +/- 1, up to sqrt(n).\",\n      \"  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {\",\n      \"    if (n % (x - 1) == 0 || n % (x + 1) == 0) {\",\n      \"      return false;\",\n      \"    }\",\n      \"  }\",\n      \"  return true;\",\n      \"}\",\n    ]);\n    code = functionName + \"(\" + number_to_check + \")\";\n    return [code, Solidity.ORDER_FUNCTION_CALL];\n  }\n  switch (dropdown_property) {\n    case \"EVEN\":\n      code = number_to_check + \" % 2 == 0\";\n      break;\n    case \"ODD\":\n      code = number_to_check + \" % 2 == 1\";\n      break;\n    case \"WHOLE\":\n      code = number_to_check + \" % 1 == 0\";\n      break;\n    case \"POSITIVE\":\n      code = number_to_check + \" > 0\";\n      break;\n    case \"NEGATIVE\":\n      code = number_to_check + \" < 0\";\n      break;\n    case \"DIVISIBLE_BY\":\n      var divisor =\n        Solidity.valueToCode(block, \"DIVISOR\", Solidity.ORDER_MODULUS) || \"0\";\n      code = number_to_check + \" % \" + divisor + \" == 0\";\n      break;\n  }\n  return [code, Solidity.ORDER_EQUALITY];\n};\n\nSolidity[\"math_change\"] = function (block) {\n  // Add to a variable in place.\n  var argument0 =\n    Solidity.valueToCode(block, \"DELTA\", Solidity.ORDER_ADDITION) || \"0\";\n  var varName = Solidity.variableDB_.getName(\n    block.getFieldValue(\"VAR\"),\n    Blockly.Variables.NAME_TYPE\n  );\n  return (\n    varName +\n    \" = (typeof \" +\n    varName +\n    \" == 'number' ? \" +\n    varName +\n    \" : 0) + \" +\n    argument0 +\n    \";\\n\"\n  );\n};\n\n// Rounding functions have a single operand.\nSolidity[\"math_round\"] = Solidity[\"math_single\"];\n// Trigonometry functions have a single operand.\nSolidity[\"math_trig\"] = Solidity[\"math_single\"];\n\nSolidity[\"math_on_list\"] = function (block) {\n  // Math functions for lists.\n  var func = block.getFieldValue(\"OP\");\n  var list, code;\n  switch (func) {\n    case \"SUM\":\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_MEMBER) || \"[]\";\n      code = list + \".reduce(function(x, y) {return x + y;})\";\n      break;\n    case \"MIN\":\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_COMMA) || \"[]\";\n      code = \"Math.min.apply(null, \" + list + \")\";\n      break;\n    case \"MAX\":\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_COMMA) || \"[]\";\n      code = \"Math.max.apply(null, \" + list + \")\";\n      break;\n    case \"AVERAGE\":\n      // mathMean([null,null,1,3]) == 2.0.\n      var functionName = Solidity.provideFunction_(\"mathMean\", [\n        \"function \" + Solidity.FUNCTION_NAME_PLACEHOLDER_ + \"(myList) {\",\n        \"  return myList.reduce(function(x, y) {return x + y;}) / \" +\n          \"myList.length;\",\n        \"}\",\n      ]);\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_NONE) || \"[]\";\n      code = functionName + \"(\" + list + \")\";\n      break;\n    case \"MEDIAN\":\n      // mathMedian([null,null,1,3]) == 2.0.\n      var functionName = Solidity.provideFunction_(\"mathMedian\", [\n        \"function \" + Solidity.FUNCTION_NAME_PLACEHOLDER_ + \"(myList) {\",\n        \"  var localList = myList.filter(function (x) \" +\n          \"{return typeof x == 'number';});\",\n        \"  if (!localList.length) return null;\",\n        \"  localList.sort(function(a, b) {return b - a;});\",\n        \"  if (localList.length % 2 == 0) {\",\n        \"    return (localList[localList.length / 2 - 1] + \" +\n          \"localList[localList.length / 2]) / 2;\",\n        \"  } else {\",\n        \"    return localList[(localList.length - 1) / 2];\",\n        \"  }\",\n        \"}\",\n      ]);\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_NONE) || \"[]\";\n      code = functionName + \"(\" + list + \")\";\n      break;\n    case \"MODE\":\n      // As a list of numbers can contain more than one mode,\n      // the returned result is provided as an array.\n      // Mode of [3, 'x', 'x', 1, 1, 2, '3'] -> ['x', 1].\n      var functionName = Solidity.provideFunction_(\"mathModes\", [\n        \"function \" + Solidity.FUNCTION_NAME_PLACEHOLDER_ + \"(values) {\",\n        \"  var modes = [];\",\n        \"  var counts = [];\",\n        \"  var maxCount = 0;\",\n        \"  for (var i = 0; i < values.length; i++) {\",\n        \"    var value = values[i];\",\n        \"    var found = false;\",\n        \"    var thisCount;\",\n        \"    for (var j = 0; j < counts.length; j++) {\",\n        \"      if (counts[j][0] === value) {\",\n        \"        thisCount = ++counts[j][1];\",\n        \"        found = true;\",\n        \"        break;\",\n        \"      }\",\n        \"    }\",\n        \"    if (!found) {\",\n        \"      counts.push([value, 1]);\",\n        \"      thisCount = 1;\",\n        \"    }\",\n        \"    maxCount = Math.max(thisCount, maxCount);\",\n        \"  }\",\n        \"  for (var j = 0; j < counts.length; j++) {\",\n        \"    if (counts[j][1] == maxCount) {\",\n        \"        modes.push(counts[j][0]);\",\n        \"    }\",\n        \"  }\",\n        \"  return modes;\",\n        \"}\",\n      ]);\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_NONE) || \"[]\";\n      code = functionName + \"(\" + list + \")\";\n      break;\n    case \"STD_DEV\":\n      var functionName = Solidity.provideFunction_(\"mathStandardDeviation\", [\n        \"function \" + Solidity.FUNCTION_NAME_PLACEHOLDER_ + \"(numbers) {\",\n        \"  var n = numbers.length;\",\n        \"  if (!n) return null;\",\n        \"  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;\",\n        \"  var variance = 0;\",\n        \"  for (var j = 0; j < n; j++) {\",\n        \"    variance += Math.pow(numbers[j] - mean, 2);\",\n        \"  }\",\n        \"  variance = variance / n;\",\n        \"  return Math.sqrt(variance);\",\n        \"}\",\n      ]);\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_NONE) || \"[]\";\n      code = functionName + \"(\" + list + \")\";\n      break;\n    case \"RANDOM\":\n      var functionName = Solidity.provideFunction_(\"mathRandomList\", [\n        \"function \" + Solidity.FUNCTION_NAME_PLACEHOLDER_ + \"(list) {\",\n        \"  var x = Math.floor(Math.random() * list.length);\",\n        \"  return list[x];\",\n        \"}\",\n      ]);\n      list = Solidity.valueToCode(block, \"LIST\", Solidity.ORDER_NONE) || \"[]\";\n      code = functionName + \"(\" + list + \")\";\n      break;\n    default:\n      throw \"Unknown operator: \" + func;\n  }\n  return [code, Solidity.ORDER_FUNCTION_CALL];\n};\n\nSolidity[\"math_modulo\"] = function (block) {\n  // Remainder computation.\n  var argument0 =\n    Solidity.valueToCode(block, \"DIVIDEND\", Solidity.ORDER_MODULUS) || \"0\";\n  var argument1 =\n    Solidity.valueToCode(block, \"DIVISOR\", Solidity.ORDER_MODULUS) || \"0\";\n  var code = argument0 + \" % \" + argument1;\n  return [code, Solidity.ORDER_MODULUS];\n};\n\nSolidity[\"math_constrain\"] = function (block) {\n  // Constrain a number between two limits.\n  var argument0 =\n    Solidity.valueToCode(block, \"VALUE\", Solidity.ORDER_COMMA) || \"0\";\n  var argument1 =\n    Solidity.valueToCode(block, \"LOW\", Solidity.ORDER_COMMA) || \"0\";\n  var argument2 =\n    Solidity.valueToCode(block, \"HIGH\", Solidity.ORDER_COMMA) || \"Infinity\";\n  var code =\n    \"Math.min(Math.max(\" +\n    argument0 +\n    \", \" +\n    argument1 +\n    \"), \" +\n    argument2 +\n    \")\";\n  return [code, Solidity.ORDER_FUNCTION_CALL];\n};\n\nSolidity[\"math_random_int\"] = function (block) {\n  // Random integer between [X] and [Y].\n  var argument0 =\n    Solidity.valueToCode(block, \"FROM\", Solidity.ORDER_COMMA) || \"0\";\n  var argument1 =\n    Solidity.valueToCode(block, \"TO\", Solidity.ORDER_COMMA) || \"0\";\n  var functionName = Solidity.provideFunction_(\"mathRandomInt\", [\n    \"function \" + Solidity.FUNCTION_NAME_PLACEHOLDER_ + \"(a, b) {\",\n    \"  if (a > b) {\",\n    \"    // Swap a and b to ensure a is smaller.\",\n    \"    var c = a;\",\n    \"    a = b;\",\n    \"    b = c;\",\n    \"  }\",\n    \"  return Math.floor(Math.random() * (b - a + 1) + a);\",\n    \"}\",\n  ]);\n  var code = functionName + \"(\" + argument0 + \", \" + argument1 + \")\";\n  return [code, Solidity.ORDER_FUNCTION_CALL];\n};\n\nSolidity[\"math_random_float\"] = function (block) {\n  // Random fraction between 0 and 1.\n  return [\"Math.random()\", Solidity.ORDER_FUNCTION_CALL];\n};\n\n\nSolidity[\"variables_get\"] = function (block) {\n  // Variable getter.\n  var code = Solidity.variableDB_.getName(\n    block.getFieldValue(\"VAR\"),\n    Blockly.Variables.NAME_TYPE\n  );\n  return [code, Solidity.ORDER_ATOMIC];\n};\n\nSolidity[\"variables_set\"] = function (block) {\n  // Variable setter.\n  var argument0 =\n    Solidity.valueToCode(block, \"VALUE\", Solidity.ORDER_ASSIGNMENT) || \"0\";\n  var varName = Solidity.variableDB_.getName(\n    block.getFieldValue(\"VAR\"),\n    Blockly.Variables.NAME_TYPE\n  );\n  return varName + \" = \" + argument0 + \";\\n\";\n};\n\n// Loops\n\nSolidity['controls_repeat_ext'] = function(block) {\n  // Repeat n times.\n  let repeats = Solidity.valueToCode(block, 'TIMES', Solidity.ORDER_ASSIGNMENT) || '0';\n  let branch = Solidity.statementToCode(block, 'DO');\n  branch = Solidity.addLoopTrap(branch, block);\n  const loopVar =\n      Solidity.nameDB_.getDistinctName('i', \"NameType.VARIABLE\");\n  let endVar = repeats;\n  const code = `for (uint ${loopVar} = 0; ${loopVar} < ${endVar}; ${loopVar}++) {\\n ${branch}\\n}\\n`;\n  return code;\n};\n\nSolidity['controls_flow_statements'] = function(block) {\n  // Flow statements: continue, break.\n  let xfix = '';\n  if (Solidity.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    xfix += Solidity.injectId(Solidity.STATEMENT_PREFIX, block);\n  }\n  if (Solidity.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the break/continue is triggered.\n    xfix += Solidity.injectId(Solidity.STATEMENT_SUFFIX, block);\n  }\n  if (Solidity.STATEMENT_PREFIX) {\n    const loop = block.getSurroundLoop();\n    if (loop && !loop.suppressPrefixSuffix) {\n      // Inject loop's statement prefix here since the regular one at the end\n      // of the loop will not get executed if 'continue' is triggered.\n      // In the case of 'break', a prefix is needed due to the loop's suffix.\n      xfix += Solidity.injectId(Solidity.STATEMENT_PREFIX, loop);\n    }\n  }\n  switch (block.getFieldValue('FLOW')) {\n    case 'BREAK':\n      return xfix + 'break;\\n';\n    case 'CONTINUE':\n      return xfix + 'continue;\\n';\n  }\n  throw Error('Unknown flow statement.');\n};\n\nSolidity['controls_whileUntil'] = function(block) {\n  // Do while/until loop.\n  const until = block.getFieldValue('MODE') === 'UNTIL';\n  let argument0 =\n      Solidity.valueToCode(\n          block, 'BOOL',\n          until ? Solidity.ORDER_LOGICAL_NOT : Solidity.ORDER_NONE) ||\n      'false';\n  let branch = Solidity.statementToCode(block, 'DO');\n  branch = Solidity.addLoopTrap(branch, block);\n  if (until) {\n    argument0 = '!' + argument0;\n  }\n  return 'while (' + argument0 + ') {\\n' + branch + '}\\n';\n};",["74","75"],"/Users/tm/blockly_solidity/client/src/blocks/customblocks.js",["76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109"],"import * as Blockly from \"blockly/core\";\n// import { Solidity } from \"../generator/generator\";\n\nBlockly.Solidity = new Blockly.Generator(\"Solidity\");\n\nBlockly.Solidity.LABEL_GROUP_STATE = \"state\";\nBlockly.Solidity.LABEL_GROUP_PARAMETER = \"parameter\";\nBlockly.Solidity.LABEL_GROUP_VARIABLE = \"variable\";\nBlockly.Solidity.LABEL_GROUP_METHOD = \"method\";\nBlockly.Solidity.UNDEFINED_NAME = \"__UNDEFINED__\";\nBlockly.Solidity.LABEL_GROUP_MAP = \"map\";\nBlockly.Solidity.LABEL_GROUP_NMAP = \"nmap\";\nBlockly.Solidity.LABEL_GROUP_EVENT = \"event\";\n\n/**\n * List of illegal variable names.\n * This is not intended to be a security feature.  Blockly is 100% client-side,\n * so bypassing this list is trivial.  This is intended to prevent users from\n * accidentally clobbering a built-in object or function.\n * @private\n */\nBlockly.Solidity.addReservedWords(\n  \"Blockly,\" + // In case JS is evaled in the current window.\n    \"abstract, after, case, catch, default, final, in, inline, let, match,\" +\n    \"null, of, relocatable, static, switch, try, type, typeof\"\n  // TODO: Fix with reference to:\n  // https://solidity.readthedocs.io/en/develop/miscellaneous.html\n  // http://solidity.readthedocs.io/en/latest/units-and-global-variables.html\n);\n\n\n\nBlockly.Extensions.register(\"declare_typed_variable\", function () {\n  var block = this;\n\n  if (!this.getVariableNameField) {\n    throw \"missing getVariableNameField method\";\n  }\n\n  if (!this.getVariableType) {\n    throw \"missing getVariableType method\";\n  }\n\n  if (!this.getVariableGroup) {\n    throw \"missing getVariableGroup method\";\n  }\n\n  if (!this.getVariableScope) {\n    throw \"missing getVariableScope method\";\n  }\n\n  this.declareOrUpdateVariable = function (name, force = false) {\n    var oldName = this.getVariableNameField().getValue();\n\n    if (!this.getParent()) {\n      return oldName;\n    }\n\n    if (!force && (!this.getParent() || oldName == name)) {\n      return oldName;\n    }\n\n    var group = this.getVariableGroup();\n    var scope = this.getVariableScope();\n    var type = this.getVariableType();\n\n    if (!Blockly.Solidity.getVariableByNameAndScope(name, scope, group)) {\n      newName = name;\n    } else {\n      var count = 2;\n      var newName = name + count;\n      while (\n        Blockly.Solidity.getVariableByNameAndScope(newName, scope, group)\n      ) {\n        count++;\n        newName = name + count;\n      }\n    }\n\n    var variable = Blockly.Solidity.getVariableById(this.workspace, this.id);\n    if (!variable) {\n      Blockly.Solidity.createVariable(\n        this.workspace,\n        group,\n        type,\n        newName,\n        scope,\n        this.id\n      );\n    } else {\n      variable.name = newName;\n    }\n\n    if (force) {\n      this.getVariableNameField().setValue(newName);\n    }\n\n    Blockly.Solidity.updateWorkspaceNameFields(this.workspace);\n\n    return newName;\n  };\n\n  this.getVariableNameField().setValidator(function (name) {\n    return block.declareOrUpdateVariable(name);\n  });\n\n  var onchange = null;\n  // if (goog.isFunction(this.onchange)) {\n  //   onchange = this.onchange;\n  // }\n\n  this.setOnChange(function (event) {\n    Blockly.Solidity.updateWorkspaceNameFields(this.workspace);\n    Blockly.Solidity.updateWorkspaceStateTypes(this.workspace);\n    Blockly.Solidity.updateWorkspaceParameterTypes(this.workspace);\n\n    if (event.blockId != this.id) {\n      return;\n    }\n\n    if (event.type == \"move\" && !!event.oldParentId) {\n      if (!!Blockly.Solidity.getVariableById(this.workspace, this.id)) {\n        this.workspace.deleteVariableById(this.id);\n      }\n    }\n    if (event.type == \"move\" && !!event.newParentId) {\n      if (!this.workspace.getVariableById(this.id)) {\n        this.declareOrUpdateVariable(\n          this.getVariableNameField().getValue(),\n          true\n        );\n      }\n    }\n    if (event.element == \"field\" && event.name == \"TYPE\") {\n      var variable = this.workspace.getVariableById(this.id);\n\n      variable.type = this.getVariableType();\n      Blockly.Solidity.updateWorkspaceStateTypes(this.workspace);\n    }\n\n    if (!!onchange) {\n      onchange.call(block, event);\n    }\n  });\n});\n\nBlockly.Solidity.updateWorkspaceNameFields = function (workspace) {\n  var blocks = workspace.getAllBlocks();\n  for (var i = 0; i < blocks.length; ++i) {\n    var nameField = blocks[i].getVariableNameSelectField\n      ? blocks[i].getVariableNameSelectField()\n      : null;\n    var group = blocks[i].getVariableLabelGroup\n      ? blocks[i].getVariableLabelGroup()\n      : null;\n\n    if (!!nameField && !!group) {\n      var vars = Blockly.Solidity.getVariablesInScope(blocks[i], group);\n      var options = vars.map(function (v) {\n        return [Blockly.Solidity.getVariableName(v), v.id_];\n      });\n\n      var selectedOption = nameField.getValue();\n\n      console.log(\"selected option => \", selectedOption);\n      if (options.length != 0) {\n        var wasUndefined =\n          nameField.menuGenerator_[0][1] == Blockly.Solidity.UNDEFINED_NAME;\n\n        nameField.menuGenerator_ = options;\n        if (wasUndefined) {\n          nameField.setValue(options[0][1]);\n        } else {\n          nameField.setValue(selectedOption);\n          // The text input does not redraw/update itself after we call \"setValue\",\n          // so we set the text manually.\n          // nameField.setText(\n          //   options.filter(function (o) { return o[1] == selectedOption })[0][0]\n          // );\n        }\n      }\n    }\n  }\n};\n\nBlockly.Solidity.updateWorkspaceTypes = function (\n  workspace,\n  nameFieldName,\n  valueFieldName\n) {\n  var blocks = workspace.getAllBlocks();\n  var vars = workspace.getAllVariables();\n\n  for (var i = 0; i < blocks.length; ++i) {\n    var stateNameField = blocks[i].getField(nameFieldName);\n\n    if (!stateNameField) {\n      continue;\n    }\n\n    var variableId = blocks[i].getFieldValue(nameFieldName);\n    var variable = workspace.getVariableById(variableId);\n\n    if (!variable) {\n      return;\n    }\n\n    if (\n      blocks[i].inputList[0] &&\n      blocks[i].inputList[0].name == valueFieldName\n    ) {\n      switch (variable.type) {\n        case \"TYPE_BOOL\":\n          blocks[i].inputList[0].setCheck(\"Boolean\");\n          break;\n        case \"TYPE_INT\":\n          blocks[i].inputList[0].setCheck(\"Number\");\n          break;\n        case \"TYPE_UINT\":\n          blocks[i].inputList[0].setCheck(\"Number\");\n          break;\n        default:\n      }\n    }\n    // TODO: update the output type\n  }\n};\n\nBlockly.Solidity.updateWorkspaceStateTypes = function (workspace) {\n  Blockly.Solidity.updateWorkspaceTypes(workspace, \"STATE_NAME\", \"STATE_VALUE\");\n};\n\nBlockly.Solidity.updateWorkspaceParameterTypes = function (workspace) {\n  Blockly.Solidity.updateWorkspaceTypes(workspace, \"PARAM_NAME\", \"PARAM_VALUE\");\n};\n\nBlockly.Solidity.createVariable = function (\n  workspace,\n  group,\n  type,\n  name,\n  scope,\n  id\n) {\n  var variable = workspace.createVariable(name, type, id);\n\n  variable.group = group;\n  variable.scope = scope;\n\n  Blockly.Solidity.setVariableName(variable, name);\n\n  return variable;\n};\n\nBlockly.Solidity.getVariableById = function (workspace, id) {\n  return workspace.getVariableById(id);\n};\n\nBlockly.Solidity.getVariableByName = function (workspace, name) {\n  return Blockly.Solidity.getAllVariables(workspace).filter(function (v) {\n    return Blockly.Solidity.getVariableName(v) == name;\n  })[0];\n};\n\nBlockly.Solidity.getVariableByNameAndScope = function (\n  name,\n  scope,\n  group = null\n) {\n  return Blockly.Solidity.getVariablesInScope(scope, group).filter(function (\n    v\n  ) {\n    return Blockly.Solidity.getVariableName(v) == name;\n  })[0];\n};\n\nBlockly.Solidity.deleteVariableById = function (workspace, id) {\n  Blockly.Solidity.deleteVariableByName(\n    workspace,\n    Blockly.Solidity.getVariableById(workspace, id).name\n  );\n};\n\nBlockly.Solidity.deleteVariableByName = function (workspace, name) {\n  return workspace.deleteVariable(name);\n};\n\nBlockly.Solidity.variableIsInScope = function (variable, scope) {\n  while (!!scope && scope.id != variable.scope.id) {\n    var type = scope.type;\n    do {\n      scope = scope.getParent();\n    } while (scope && type == scope.type);\n  }\n\n  return !!scope;\n};\n\nBlockly.Solidity.setVariableName = function (variable, name) {\n  variable.name = '_scope(\"' + variable.scope.id + '\")_' + name;\n};\n\nBlockly.Solidity.getVariableName = function (variable) {\n  return variable.name.replace('_scope(\"' + variable.scope.id + '\")_', \"\");\n};\n\nBlockly.Solidity.getAllVariables = function (workspace) {\n  return workspace.getAllVariables();\n};\n\nBlockly.Solidity.getVariablesInScope = function (block, group = null) {\n  return Blockly.Solidity.getAllVariables(block.workspace)\n    .filter(function (v) {\n      return Blockly.Solidity.variableIsInScope(v, block);\n    })\n    .filter(function (v) {\n      return !group || v.group == group;\n    });\n};\n\nBlockly.defineBlocksWithJsonArray([\n  {\n    type: \"contract\",\n    message0: \"smart contract %1\",\n    args0: [\n      {\n        type: \"field_input\",\n        name: \"NAME\",\n        check: \"String\",\n        text: \"MyContract\",\n      },\n    ],\n    message1: \"states %1\",\n    args1: [\n      {\n        type: \"input_statement\",\n        name: \"STATES\",\n        check: [\"contract_state\"],\n        align: \"RIGHT\",\n      },\n    ],\n    message2: \"constructor %1\",\n    args2: [\n      {\n        type: \"input_statement\",\n        name: \"CTOR\",\n        check: [\"contract_ctor\"],\n        align: \"RIGHT\",\n      },\n    ],\n    message3: \"methods %1\",\n    args3: [\n      {\n        type: \"input_statement\",\n        name: \"METHODS\",\n        check: [\"contract_method\"],\n        align: \"RIGHT\",\n      },\n    ],\n    colour: 160,\n    tooltip: \"Declares a new smart contract.\",\n  },\n]);\n\nBlockly.Blocks[\"contract_state\"] = {\n  init: function () {\n    var nameField = new Blockly.FieldTextInput(\"s\");\n    this.appendDummyInput()\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"bool\", \"TYPE_BOOL\"],\n          [\"int\", \"TYPE_INT\"],\n          [\"uint\", \"TYPE_UINT\"],\n          [\"string\", \"TYPE_STRING\"],\n          [\"address\", \"TYPE_ADDRESS\"],\n        ]),\n        \"TYPE\"\n      )\n      .appendField(nameField, \"NAME\");\n    this.setPreviousStatement(true, \"contract_state\");\n    this.setNextStatement(true, \"contract_state\");\n    this.setColour(195);\n    this.contextMenu = false;\n\n    this._stateNameInitialized = false;\n\n    this.getVariableNameField = function () {\n      return nameField;\n    };\n    this.getVariableType = function () {\n      return this.getFieldValue(\"TYPE\");\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_STATE;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (!!scope && scope.type != \"contract\") {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n\n    // Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\nBlockly.Blocks[\"contract_state_get\"] = {\n  init: function () {\n    this.appendDummyInput().appendField(\n      new Blockly.FieldDropdown([\n        [\"select state...\", Blockly.Solidity.UNDEFINED_NAME],\n      ]),\n      \"STATE_NAME\"\n    );\n    this.setOutput(true, null);\n    this.setColour(195);\n\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"STATE_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_STATE;\n    };\n  },\n};\n\nBlockly.Blocks[\"contract_state_set\"] = {\n  init: function () {\n    this.appendValueInput(\"STATE_VALUE\")\n      .appendField(\"set\")\n      .appendField(\n        new Blockly.FieldDropdown(\n          [[\"select state...\", Blockly.Solidity.UNDEFINED_NAME]],\n          this.validate\n        ),\n        \"STATE_NAME\"\n      )\n      .appendField(\"to\");\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(195);\n\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"STATE_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_STATE;\n    };\n  },\n\n  validate: function (stateNameVariableId) {\n    var workspace = this.sourceBlock_.workspace;\n    // FIXME: dirty hack to make sure updateWorkspaceStateTypes is called right after validate\n    setTimeout(function () {\n      Blockly.Solidity.updateWorkspaceStateTypes(workspace);\n    }, 1);\n    return stateNameVariableId;\n  },\n};\n\n// contract_method_parameter_memory\nBlockly.Blocks[\"contract_method_parameter_memory\"] = {\n  init: function () {\n    var nameField = new Blockly.FieldTextInput(\"p\");\n    this.appendDummyInput()\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"bool\", \"TYPE_BOOL\"],\n          [\"int\", \"TYPE_INT\"],\n          [\"uint\", \"TYPE_UINT\"],\n          [\"string\", \"TYPE_STRING\"],\n          [\"address\", \"TYPE_ADDRESS\"],\n        ]),\n        \"TYPE\"\n      )\n      .appendField(nameField, \"NAME\");\n    this.setPreviousStatement(true, \"contract_method_parameter\");\n    this.setNextStatement(true, \"contract_method_parameter\");\n    this.setColour(320);\n    this.contextMenu = false;\n\n    this.getVariableNameField = function () {\n      return nameField;\n    };\n    this.getVariableType = function () {\n      return this.getFieldValue(\"TYPE\");\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_PARAMETER;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (\n        !!scope &&\n        scope.type != \"contract_method\" &&\n        scope.type != \"contract_ctor\"\n      ) {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\n// contract_method_parameter\n\nBlockly.Blocks[\"contract_method_parameter\"] = {\n  init: function () {\n    var nameField = new Blockly.FieldTextInput(\"m\");\n    this.appendDummyInput()\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"bool\", \"TYPE_BOOL\"],\n          [\"int\", \"TYPE_INT\"],\n          [\"uint\", \"TYPE_UINT\"],\n          [\"string\", \"TYPE_STRING\"],\n          [\"address\", \"TYPE_ADDRESS\"],\n        ]),\n        \"TYPE\"\n      )\n      .appendField(nameField, \"NAME\");\n    this.setPreviousStatement(\n      true,\n      \"contract_method_parameter\",\n      \"contract_method_parameter_memory\"\n    );\n    this.setNextStatement(\n      true,\n      \"contract_method_parameter\",\n      \"contract_method_parameter_memory\"\n    );\n    this.setColour(115);\n    this.contextMenu = false;\n\n    this.getVariableNameField = function () {\n      return nameField;\n    };\n    this.getVariableType = function () {\n      return this.getFieldValue(\"TYPE\");\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_PARAMETER;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (\n        !!scope &&\n        scope.type != \"contract_method\" &&\n        scope.type != \"contract_ctor\"\n      ) {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\nBlockly.Blocks[\"contract_method_parameter_get\"] = {\n  init: function () {\n    this.appendValueInput(\"method_get\").appendField(\n      new Blockly.FieldDropdown([\n        [\"select param...\", Blockly.Solidity.UNDEFINED_NAME],\n      ]),\n      \"PARAM_NAME\"\n    );\n    this.setOutput(true, null);\n    this.setColour(160);\n\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"PARAM_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_PARAMETER;\n    };\n  },\n};\n\nBlockly.Blocks[\"contract_method\"] = {\n  init: function () {\n    this.jsonInit({\n      message0: \"method %1 %2 %3 %4 %5 %6\",\n      args0: [\n        {\n          type: \"field_input\",\n          name: \"NAME\",\n          text: \"myMethod\",\n        },\n        {\n          type: \"field_dropdown\",\n          name: \"ACCESS\",\n          options: [\n            [\"public\", \"public\"],\n            [\"private\", \"private\"],\n            [\"external\", \"external\"],\n            [\"internal\", \"internal\"],\n          ],\n        },\n        {\n          type: \"field_dropdown\",\n          name: \"STATE_CHANGE\",\n          options: [\n            [\"none\", \"none\"],\n            [\"pure\", \"pure\"],\n            [\"view\", \"view\"],\n            [\"constant\", \"constant\"],\n            [\"payable\", \"payable\"],\n          ],\n        },\n        {\n          type: \"field_label_serializable\",\n          name: \"RETURNS\",\n          text: \"returns\",\n        },\n        {\n          type: \"field_dropdown\",\n          name: \"Function_Ouput\",\n          options: [\n            [\"none\", \"none\"],\n            [\"bool\", \"bool\"],\n            [\"int\", \"int\"],\n            [\"uint\", \"uint\"],\n            [\"string\", \"string\"],\n            [\"address\", \"address\"],\n            [\"bytes\", \"bytes\"],\n          ],\n        },\n        {\n          type: \"field_input\",\n          name: \"Variable_name\",\n          text: \"VariableName\",\n        },\n      ],\n      message1: \"parameters %1\",\n      args1: [\n        {\n          type: \"input_statement\",\n          name: \"PARAMS\",\n          check: [\"contract_method_parameter\"],\n          align: \"RIGHT\",\n        },\n      ],\n      message2: \"code %1\",\n      args2: [\n        {\n          type: \"input_statement\",\n          name: \"STACK\",\n          align: \"RIGHT\",\n        },\n      ],\n      previousStatement: \"contract_method\",\n      nextStatement: \"contract_method\",\n      colour: 290,\n      tooltip: \"\",\n      helpUrl: \"\",\n    });\n\n    this.getVariableNameField = function () {\n      return this.getField(\"NAME\");\n    };\n    this.getVariableType = function () {\n      return \"void\";\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_METHOD;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (!!scope && scope.type != \"contract\") {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\nBlockly.Blocks[\"contract_method_call\"] = {\n  init: function () {\n    this.appendValueInput(\"call_method\")\n      .appendField(\"call method\")\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"select method...\", Blockly.Solidity.UNDEFINED_NAME],\n        ]),\n        \"METHOD_NAME\"\n      );\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    // this.setOutput(true, null);\n    this.setColour(320);\n\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"METHOD_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_METHOD;\n    };\n\n    this.setOnChange(function (event) {\n      if (event.blockId != this.id) {\n        return;\n      }\n\n      if (event.element == \"field\" && event.name == \"METHOD_NAME\") {\n        var methodId = this.getFieldValue(\"METHOD_NAME\");\n        var methodBlock = this.workspace.getBlockById(methodId);\n        var params = [];\n\n        var block = methodBlock;\n        do {\n          block = block.getChildren().filter(function (c) {\n            return c.type == \"contract_method_parameter\";\n          })[0];\n\n          if (block) {\n            params.push(block);\n          }\n        } while (block);\n\n        console.log(params);\n        // FIXME: add/remove inputs according to the method params\n      }\n    });\n  },\n};\n\nBlockly.Blocks['method_argument'] = {\n  init: function() {\n    this.appendValueInput(\"method_argument\")\n        .setCheck(\"method_argument\")\n        .appendField(new Blockly.FieldTextInput(\"arg\"), \"NAME\");\n    this.setInputsInline(false);\n    this.setOutput(true, null);\n    this.setColour(45);\n this.setTooltip(\"The block to pass argument to functions\");\n this.setHelpUrl(\"\");\n  }\n};\n\nBlockly.defineBlocksWithJsonArray([\n  {\n    type: \"contract_ctor\",\n    message0: \"constructor\",\n    message1: \"parameters %1\",\n    args1: [\n      {\n        type: \"input_statement\",\n        name: \"PARAMS\",\n        check: \"contract_method_parameter\",\n        align: \"RIGHT\",\n      },\n    ],\n    message2: \"code %1\",\n    args2: [\n      {\n        type: \"input_statement\",\n        name: \"STACK\",\n        align: \"RIGHT\",\n      },\n    ],\n    previousStatement: [\"contract_ctor\"],\n    colour: 290,\n    tooltip: \"\",\n    helpUrl: \"\",\n  },\n]);\n\nBlockly.defineBlocksWithJsonArray([\n  {\n    type: \"contract_intrinsic_sha3\",\n    message0: \"sha3 %1\",\n    args0: [\n      {\n        type: \"input_value\",\n        name: \"VALUE\",\n      },\n    ],\n    output: null,\n    colour: 60,\n    tooltip: \"\",\n    helpUrl: \"\",\n  },\n]);\n\nBlockly.Blocks[\"controls_for\"] = {\n  init: function () {\n    this.jsonInit({\n      message0: \"%{BKY_CONTROLS_FOR_TITLE}\",\n      args0: [\n        {\n          type: \"field_input\",\n          name: \"VAR\",\n          text: \"i\",\n        },\n        {\n          type: \"input_value\",\n          name: \"FROM\",\n          check: \"Number\",\n          align: \"RIGHT\",\n        },\n        {\n          type: \"input_value\",\n          name: \"TO\",\n          check: \"Number\",\n          align: \"RIGHT\",\n        },\n        {\n          type: \"input_value\",\n          name: \"BY\",\n          check: \"Number\",\n          align: \"RIGHT\",\n        },\n      ],\n      message1: \"%{BKY_CONTROLS_REPEAT_INPUT_DO} %1\",\n      args1: [\n        {\n          type: \"input_statement\",\n          name: \"DO\",\n        },\n      ],\n      inputsInline: true,\n      previousStatement: null,\n      nextStatement: null,\n      colour: \"%{BKY_LOOPS_HUE}\",\n      helpUrl: \"%{BKY_CONTROLS_FOR_HELPURL}\",\n    });\n\n    this.getVariableNameField = function () {\n      return this.getField(\"VAR\");\n    };\n    this.getVariableType = function () {\n      return \"TYPE_UINT\";\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_VARIABLE;\n    };\n    this.getVariableScope = function () {\n      return this;\n    };\n\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\nBlockly.Blocks[\"state\"] = {\n  init: function () {\n    const nameField = new Blockly.FieldTextInput(\"Variable Name\");\n    this.appendValueInput(\"state\")\n      .setCheck(null)\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"bytes\", \"bytes\"],\n          [\"bool\", \"bool\"],\n          [\"int\", \"int\"],\n          [\"string\", \"string\"],\n          [\"uint\", \"uint\"],\n          [\"address\", \"address\"],\n        ]),\n        \"state_variables\"\n      )\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"public\", \"public\"],\n          [\"private\", \"private\"],\n        ]),\n        \"visibility\"\n      )\n      .appendField(nameField, \"NAME\");\n    this.setPreviousStatement(true, \"contract_state\");\n    this.setNextStatement(true, null);\n    this.setColour(230);\n    this.setTooltip(\"\");\n    this.setHelpUrl(\"\");\n    this.contextMenu = false;\n\n    this._stateNameInitialized = false;\n\n    this.getVariableNameField = function () {\n      return nameField;\n    };\n    this.getVariableType = function () {\n      return this.getFieldValue(\"TYPE\");\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_STATE;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (!!scope && scope.type != \"contract\") {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\n// Mapping blocks.\nBlockly.Blocks[\"mapping\"] = {\n  init: function () {\n    const nameField = new Blockly.FieldTextInput(\"mapping_name\");\n    this.appendValueInput(\"key\").setCheck(null).appendField(\"map\");\n    this.appendValueInput(\"value\").setCheck(null).appendField(\"to\");\n    this.appendDummyInput().appendField(\n      new Blockly.FieldDropdown([\n        [\"public\", \"public\"],\n        [\"private\", \"private\"],\n      ]),\n      \"visibility\"\n    );\n    this.appendDummyInput().appendField(nameField, \"NAME\");\n    this.setInputsInline(true);\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(225);\n    this.setTooltip(\"4\");\n    this.setHelpUrl(\"7\");\n    this.contextMenu = false;\n\n    this._stateNameInitialized = false;\n\n    this.getVariableNameField = function () {\n      return nameField;\n    };\n    this.getVariableType = function () {\n      return this.getFieldValue(\"TYPE\");\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_MAP;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (!!scope && scope.type != \"contract\") {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\nBlockly.Blocks[\"mapping_set\"] = {\n  init: function () {\n    this.appendValueInput(\"mapping_name\")\n      .appendField(\"set\")\n      .appendField(\n        new Blockly.FieldDropdown(\n          [[\"select mapping....\", Blockly.Solidity.UNDEFINED_NAME]],\n          this.validate\n        ),\n        \"MAPPING_NAME\"\n      );\n    this.appendValueInput(\"NAME\").appendField(\n      new Blockly.FieldDropdown([\n        [\"to\", \"=\"],\n        [\"EQ\", \"==\"],\n        [\"NEQ\", \"!=\"],\n        [\"GT\", \">\"],\n        [\"GTE\", \">=\"],\n        [\"NGT\", \"!>\"],\n        [\"LT\", \"<\"],\n        [\"LTE\", \"<=\"],\n        [\"NLT\", \"!<\"],\n        [\"add/reassign\", \"+=\"],\n        [\"sub/reassign\", \"-=\"],\n      ]),\n      \"compare\"\n    );\n    this.setInputsInline(true);\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(130);\n\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"MAPPING_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_MAP;\n    };\n  },\n\n  validate: function (stateNameVariableId) {\n    var workspace = this.sourceBlock_.workspace;\n    // FIXME: dirty hack to make sure updateWorkspaceStateTypes is called right after validate\n    setTimeout(function () {\n      Blockly.Solidity.updateWorkspaceStateTypes(workspace);\n    }, 1);\n    return stateNameVariableId;\n  },\n};\n\nBlockly.Blocks[\"mapping_get\"] = {\n  init: function () {\n    this.appendValueInput(\"mapping_name\")\n      .setCheck(null)\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"select mapping....\", Blockly.Solidity.UNDEFINED_NAME],\n        ]),\n        \"MAPPING_NAME\"\n      );\n    this.appendValueInput(\"compare\")\n      .setCheck(null)\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"to\", \"=\"],\n          [\"EQ\", \"==\"],\n          [\"NEQ\", \"!=\"],\n          [\"GT\", \">\"],\n          [\"GTE\", \">=\"],\n          [\"NGT\", \"!>\"],\n          [\"LT\", \"<\"],\n          [\"LTE\", \"<=\"],\n          [\"NLT\", \"!<\"],\n          [\"add/reassign\", \"+=\"],\n          [\"sub/reassign\", \"-=\"],\n        ]),\n        \"compare\"\n      );\n    this.setInputsInline(false);\n    this.setOutput(true, null);\n    this.setColour(230);\n    this.setTooltip(\"get mapping\");\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"MAPPING_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_MAP;\n    };\n  },\n};\n\nBlockly.Blocks[\"nested_mapping\"] = {\n  init: function () {\n    const nameField = new Blockly.FieldTextInput(\"nested_mapping_name\")\n    this.appendValueInput(\"firstKey\").setCheck(null).appendField(\"map\");\n    this.appendValueInput(\"secondKey\").setCheck(null).appendField(\"map\");\n    this.appendValueInput(\"value\").setCheck(null).appendField(\"to\");\n    this.appendDummyInput().appendField(\n      new Blockly.FieldDropdown([\n        [\"public\", \"public\"],\n        [\"private\", \"private\"],\n      ]),\n      \"visibility\"\n    );\n    this.appendDummyInput().appendField(\n      nameField,\n      \"NAME\"\n    );\n    this.setInputsInline(true);\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(305);\n    this.setTooltip(\"4\");\n    this.setHelpUrl(\"7\");\n    this.contextMenu = false;\n\n    this._stateNameInitialized = false;\n\n    this.getVariableNameField = function () {\n      return nameField;\n    };\n    this.getVariableType = function () {\n      return this.getFieldValue(\"TYPE\");\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_NMAP;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (!!scope && scope.type != \"contract\") {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\nBlockly.Blocks[\"nested_mapping_set\"] = {\n  init: function () {\n    this.appendValueInput(\"nested_mapping_name\")\n      .appendField(\"set\")\n      .appendField(\n        new Blockly.FieldDropdown(\n          [[\"select nestedmap....\", Blockly.Solidity.UNDEFINED_NAME]],\n          this.validate\n        ),\n        \"NESTED_MAPPING_NAME\"\n      );\n    this.appendValueInput(\"map_value\");\n    this.appendValueInput(\"NAME\").appendField(\n      new Blockly.FieldDropdown([\n        [\"to\", \"=\"],\n        [\"EQ\", \"==\"],\n        [\"NEQ\", \"!=\"],\n        [\"GT\", \">\"],\n        [\"GTE\", \">=\"],\n        [\"NGT\", \"!>\"],\n        [\"LT\", \"<\"],\n        [\"LTE\", \"<=\"],\n        [\"NLT\", \"!<\"],\n        [\"add/reassign\", \"+=\"],\n        [\"sub/reassign\", \"-=\"],\n      ]),\n      \"compare\"\n    );\n    this.setInputsInline(true);\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(180);\n\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"NESTED_MAPPING_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_NMAP;\n    };\n  },\n\n    validate: function (stateNameVariableId) {\n      var workspace = this.sourceBlock_.workspace;\n      // FIXME: dirty hack to make sure updateWorkspaceStateTypes is called right after validate\n      setTimeout(function () {\n        Blockly.Solidity.updateWorkspaceStateTypes(workspace);\n      }, 1);\n      return stateNameVariableId;\n    },\n}\n\nBlockly.Blocks['nested_mapping_get'] = {\n  init: function() {\n    this.appendValueInput(\"nmap\")\n        .setCheck(null)\n        .appendField(\n          new Blockly.FieldDropdown([\n            [\"select mapping....\", Blockly.Solidity.UNDEFINED_NAME],\n          ]),\n          \"NESTED_MAPPING_NAME\"\n        );\n    this.appendValueInput(\"NAME\")\n        .setCheck(null);\n    this.appendValueInput(\"compare\")\n        .setCheck(null)\n        .appendField(\n          new Blockly.FieldDropdown([\n            [\"to\", \"=\"],\n            [\"EQ\", \"==\"],\n            [\"NEQ\", \"!=\"],\n            [\"GT\", \">\"],\n            [\"GTE\", \">=\"],\n            [\"NGT\", \"!>\"],\n            [\"LT\", \"<\"],\n            [\"LTE\", \"<=\"],\n            [\"NLT\", \"!<\"],\n            [\"add/reassign\", \"+=\"],\n            [\"sub/reassign\", \"-=\"],\n          ]),\n          \"compare\"\n        );\n    this.setInputsInline(true);\n    this.setOutput(true, null);\n    this.setColour(295);\n    this.setTooltip(\"get nested mapping\");\n    this.setHelpUrl(\"\");\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"NESTED_MAPPING_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_NMAP;\n    };\n  }\n};\n\nBlockly.Blocks[\"input\"] = {\n  init: function () {\n    this.appendValueInput(\"input\").appendField(\n      new Blockly.FieldTextInput(\"type\"),\n      \"NAME\"\n    );\n    this.setOutput(true, null);\n    this.setColour(330);\n    this.setTooltip(\"\");\n    this.setHelpUrl(\"\");\n  },\n};\n\nBlockly.Blocks[\"event\"] = {\n  init: function () {\n    const nameField = new Blockly.FieldTextInput(\"name\")\n    this.appendValueInput(\"event\")\n      .setCheck(null)\n      .appendField(\"event\")\n      .appendField(nameField, \"NAME\");\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(105);\n    this.setTooltip(\"\");\n    this.setHelpUrl(\"\");\n    this.contextMenu = false;\n\n    this._stateNameInitialized = false;\n\n    this.getVariableNameField = function () {\n      return nameField;\n    };\n    this.getVariableType = function () {\n      return this.getFieldValue(\"TYPE\");\n    };\n    this.getVariableGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_EVENT;\n    };\n    this.getVariableScope = function () {\n      var scope = this.getParent();\n      while (!!scope && scope.type != \"contract\") {\n        scope = scope.getParent();\n      }\n      return scope;\n    };\n\n    Blockly.Extensions.apply(\"declare_typed_variable\", this, false);\n  },\n};\n\nBlockly.Blocks[\"event_get\"] = {\n  init: function () {\n    this.appendValueInput(\"event_name\")\n      .setCheck(null)\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"select event....\", Blockly.Solidity.UNDEFINED_NAME],\n        ]),\n        \"EVENT_NAME\"\n      );\n    this.setInputsInline(false);\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(230);\n    this.setTooltip(\"emit event\");\n    this.getVariableNameSelectField = function () {\n      return this.getField(\"EVENT_NAME\");\n    };\n    this.getVariableLabelGroup = function () {\n      return Blockly.Solidity.LABEL_GROUP_EVENT;\n    };\n  },\n};\n\nBlockly.Blocks[\"event_parameter\"] = {\n  init: function () {\n    this.appendValueInput(\"event_parameter\")\n      .setCheck(null)\n      .appendField(\"Indexed\")\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"int\", \"int\"],\n          [\"address\", \"address\"],\n          [\"uint\", \"uint\"],\n          [\"string\", \"string\"],\n          [\"bytes\", \"bytes\"],\n          [\"bool\", \"bool\"],\n        ]),\n        \"type\"\n      )\n      .appendField(new Blockly.FieldTextInput(\"name\"), \"NAME\");\n    this.setOutput(true, null);\n    this.setColour(165);\n    this.setTooltip(\"\");\n    this.setHelpUrl(\"\");\n  },\n};\n\nBlockly.Blocks[\"event_param_nonindex\"] = {\n  init: function () {\n    this.appendValueInput(\"event_parameter\")\n      .setCheck(null)\n      .appendField(\"non Indexed\")\n      .appendField(\n        new Blockly.FieldDropdown([\n          [\"int\", \"int\"],\n          [\"address\", \"address\"],\n          [\"uint\", \"uint\"],\n          [\"string\", \"string\"],\n          [\"bytes\", \"bytes\"],\n          [\"bool\", \"bool\"],\n        ]),\n        \"type\"\n      )\n      .appendField(new Blockly.FieldTextInput(\"name\"), \"NAME\");\n    this.setOutput(true, null);\n    this.setColour(165);\n    this.setTooltip(\"\");\n    this.setHelpUrl(\"\");\n  },\n};\n\nBlockly.Blocks[\"space\"] = {\n  init: function () {\n    this.appendDummyInput().appendField(\"Space Down\");\n    this.setInputsInline(false);\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(230);\n    this.setTooltip(\"\");\n    this.setHelpUrl(\"\");\n  },\n};\n\nBlockly.Blocks[\"require\"] = {\n  init: function () {\n    this.appendValueInput(\"require\").setCheck(null).appendField(\"require\");\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(230);\n    this.setTooltip(\"error-handling: require\");\n    this.setHelpUrl(\"\");\n  },\n};\n\nBlockly.Blocks['boolean'] = {\n  init: function() {\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldDropdown([[\"true\",\"true\"], [\"false\",\"false\"]]), \"boolean\");\n    this.setInputsInline(false);\n    this.setOutput(true, null);\n    this.setColour(75);\n this.setTooltip(\"boolean: true or false\");\n this.setHelpUrl(\"\");\n  }\n};\n\nBlockly.Blocks['returns'] = {\n  init: function() {\n    this.appendValueInput(\"NAME\")\n        .setCheck(null)\n        .appendField(\"return\");\n    this.setInputsInline(true);\n    this.setPreviousStatement(true, null);\n    this.setNextStatement(true, null);\n    this.setColour(195);\n this.setTooltip(\"Function return\");\n this.setHelpUrl(\"\");\n  }\n};\n","/Users/tm/blockly_solidity/client/src/components/Blockly/index.js",[],"/Users/tm/blockly_solidity/client/src/components/Blockly/BlocklyComponent.jsx",[],"/Users/tm/blockly_solidity/client/src/components/Header/header.js",["110","111","112","113","114"],"/Users/tm/blockly_solidity/client/src/components/Header/styles.js",[],{"ruleId":"115","severity":1,"message":"116","line":5,"column":35,"nodeType":"117","messageId":"118","endLine":5,"endColumn":40},{"ruleId":"115","severity":1,"message":"119","line":5,"column":42,"nodeType":"117","messageId":"118","endLine":5,"endColumn":47},{"ruleId":"115","severity":1,"message":"120","line":5,"column":49,"nodeType":"117","messageId":"118","endLine":5,"endColumn":55},{"ruleId":"121","severity":2,"message":"122","line":13,"column":14,"nodeType":"123","endLine":13,"endColumn":20},{"ruleId":"115","severity":1,"message":"124","line":4,"column":8,"nodeType":"117","messageId":"118","endLine":4,"endColumn":16},{"ruleId":"125","severity":1,"message":"126","line":203,"column":35,"nodeType":"127","messageId":"128","endLine":203,"endColumn":37},{"ruleId":"129","severity":1,"message":"130","line":206,"column":15,"nodeType":"117","messageId":"131","endLine":206,"endColumn":22},{"ruleId":"125","severity":1,"message":"132","line":304,"column":26,"nodeType":"127","messageId":"128","endLine":304,"endColumn":28},{"ruleId":"125","severity":1,"message":"126","line":306,"column":42,"nodeType":"127","messageId":"128","endLine":306,"endColumn":44},{"ruleId":"115","severity":1,"message":"133","line":330,"column":7,"nodeType":"117","messageId":"118","endLine":330,"endColumn":11},{"ruleId":"125","severity":1,"message":"126","line":348,"column":35,"nodeType":"127","messageId":"128","endLine":348,"endColumn":37},{"ruleId":"125","severity":1,"message":"126","line":398,"column":40,"nodeType":"127","messageId":"128","endLine":398,"endColumn":42},{"ruleId":"125","severity":1,"message":"126","line":404,"column":40,"nodeType":"127","messageId":"128","endLine":404,"endColumn":42},{"ruleId":"125","severity":1,"message":"132","line":420,"column":30,"nodeType":"127","messageId":"128","endLine":420,"endColumn":32},{"ruleId":"125","severity":1,"message":"126","line":424,"column":28,"nodeType":"127","messageId":"128","endLine":424,"endColumn":30},{"ruleId":"125","severity":1,"message":"126","line":448,"column":32,"nodeType":"127","messageId":"128","endLine":448,"endColumn":34},{"ruleId":"125","severity":1,"message":"126","line":567,"column":35,"nodeType":"127","messageId":"128","endLine":567,"endColumn":37},{"ruleId":"125","severity":1,"message":"126","line":570,"column":42,"nodeType":"127","messageId":"128","endLine":570,"endColumn":44},{"ruleId":"134","severity":1,"message":"135","line":585,"column":29,"nodeType":"127","messageId":"136","endLine":585,"endColumn":30},{"ruleId":"125","severity":1,"message":"126","line":889,"column":44,"nodeType":"127","messageId":"128","endLine":889,"endColumn":46},{"ruleId":"125","severity":1,"message":"126","line":891,"column":14,"nodeType":"127","messageId":"128","endLine":891,"endColumn":16},{"ruleId":"125","severity":1,"message":"126","line":900,"column":36,"nodeType":"127","messageId":"128","endLine":900,"endColumn":38},{"ruleId":"125","severity":1,"message":"126","line":966,"column":16,"nodeType":"127","messageId":"128","endLine":966,"endColumn":18},{"ruleId":"125","severity":1,"message":"126","line":970,"column":16,"nodeType":"127","messageId":"128","endLine":970,"endColumn":18},{"ruleId":"125","severity":1,"message":"126","line":977,"column":16,"nodeType":"127","messageId":"128","endLine":977,"endColumn":18},{"ruleId":"125","severity":1,"message":"126","line":977,"column":37,"nodeType":"127","messageId":"128","endLine":977,"endColumn":39},{"ruleId":"125","severity":1,"message":"126","line":977,"column":58,"nodeType":"127","messageId":"128","endLine":977,"endColumn":60},{"ruleId":"137","severity":1,"message":"138","line":984,"column":3,"nodeType":"139","messageId":"140","endLine":1018,"endColumn":4},{"ruleId":"141","severity":1,"message":"142","line":1038,"column":7,"nodeType":"143","messageId":"144","endLine":1038,"endColumn":50},{"ruleId":"125","severity":1,"message":"126","line":1064,"column":25,"nodeType":"127","messageId":"128","endLine":1064,"endColumn":27},{"ruleId":"137","severity":1,"message":"138","line":1090,"column":3,"nodeType":"139","messageId":"140","endLine":1111,"endColumn":4},{"ruleId":"129","severity":1,"message":"145","line":1170,"column":11,"nodeType":"117","messageId":"131","endLine":1170,"endColumn":23},{"ruleId":"129","severity":1,"message":"145","line":1191,"column":11,"nodeType":"117","messageId":"131","endLine":1191,"endColumn":23},{"ruleId":"129","severity":1,"message":"145","line":1225,"column":11,"nodeType":"117","messageId":"131","endLine":1225,"endColumn":23},{"ruleId":"129","severity":1,"message":"145","line":1242,"column":11,"nodeType":"117","messageId":"131","endLine":1242,"endColumn":23},{"ruleId":"141","severity":1,"message":"142","line":1252,"column":7,"nodeType":"143","messageId":"144","endLine":1252,"endColumn":41},{"ruleId":"137","severity":1,"message":"138","line":1368,"column":3,"nodeType":"139","messageId":"140","endLine":1373,"endColumn":4},{"ruleId":"146","replacedBy":"147"},{"ruleId":"148","replacedBy":"149"},{"ruleId":"141","severity":1,"message":"142","line":37,"column":5,"nodeType":"143","messageId":"144","endLine":37,"endColumn":49},{"ruleId":"141","severity":1,"message":"142","line":41,"column":5,"nodeType":"143","messageId":"144","endLine":41,"endColumn":44},{"ruleId":"141","severity":1,"message":"142","line":45,"column":5,"nodeType":"143","messageId":"144","endLine":45,"endColumn":45},{"ruleId":"141","severity":1,"message":"142","line":49,"column":5,"nodeType":"143","messageId":"144","endLine":49,"endColumn":45},{"ruleId":"125","severity":1,"message":"126","line":59,"column":49,"nodeType":"127","messageId":"128","endLine":59,"endColumn":51},{"ruleId":"150","severity":1,"message":"151","line":68,"column":7,"nodeType":"117","messageId":"152","endLine":68,"endColumn":14},{"ruleId":"125","severity":1,"message":"132","line":117,"column":23,"nodeType":"127","messageId":"128","endLine":117,"endColumn":25},{"ruleId":"125","severity":1,"message":"126","line":121,"column":20,"nodeType":"127","messageId":"128","endLine":121,"endColumn":22},{"ruleId":"125","severity":1,"message":"126","line":126,"column":20,"nodeType":"127","messageId":"128","endLine":126,"endColumn":22},{"ruleId":"125","severity":1,"message":"126","line":134,"column":23,"nodeType":"127","messageId":"128","endLine":134,"endColumn":25},{"ruleId":"125","severity":1,"message":"126","line":134,"column":48,"nodeType":"127","messageId":"128","endLine":134,"endColumn":50},{"ruleId":"125","severity":1,"message":"132","line":166,"column":26,"nodeType":"127","messageId":"128","endLine":166,"endColumn":28},{"ruleId":"125","severity":1,"message":"126","line":168,"column":42,"nodeType":"127","messageId":"128","endLine":168,"endColumn":44},{"ruleId":"115","severity":1,"message":"133","line":192,"column":7,"nodeType":"117","messageId":"118","endLine":192,"endColumn":11},{"ruleId":"125","severity":1,"message":"126","line":210,"column":35,"nodeType":"127","messageId":"128","endLine":210,"endColumn":37},{"ruleId":"125","severity":1,"message":"126","line":261,"column":48,"nodeType":"127","messageId":"128","endLine":261,"endColumn":50},{"ruleId":"125","severity":1,"message":"126","line":273,"column":48,"nodeType":"127","messageId":"128","endLine":273,"endColumn":50},{"ruleId":"125","severity":1,"message":"132","line":289,"column":30,"nodeType":"127","messageId":"128","endLine":289,"endColumn":32},{"ruleId":"125","severity":1,"message":"126","line":293,"column":28,"nodeType":"127","messageId":"128","endLine":293,"endColumn":30},{"ruleId":"125","severity":1,"message":"126","line":317,"column":32,"nodeType":"127","messageId":"128","endLine":317,"endColumn":34},{"ruleId":"125","severity":1,"message":"132","line":398,"column":36,"nodeType":"127","messageId":"128","endLine":398,"endColumn":38},{"ruleId":"125","severity":1,"message":"132","line":496,"column":20,"nodeType":"127","messageId":"128","endLine":496,"endColumn":22},{"ruleId":"125","severity":1,"message":"132","line":497,"column":20,"nodeType":"127","messageId":"128","endLine":497,"endColumn":22},{"ruleId":"125","severity":1,"message":"132","line":551,"column":20,"nodeType":"127","messageId":"128","endLine":551,"endColumn":22},{"ruleId":"125","severity":1,"message":"132","line":552,"column":20,"nodeType":"127","messageId":"128","endLine":552,"endColumn":22},{"ruleId":"125","severity":1,"message":"132","line":672,"column":36,"nodeType":"127","messageId":"128","endLine":672,"endColumn":38},{"ruleId":"125","severity":1,"message":"132","line":705,"column":25,"nodeType":"127","messageId":"128","endLine":705,"endColumn":27},{"ruleId":"125","severity":1,"message":"126","line":709,"column":25,"nodeType":"127","messageId":"128","endLine":709,"endColumn":27},{"ruleId":"125","severity":1,"message":"126","line":709,"column":50,"nodeType":"127","messageId":"128","endLine":709,"endColumn":52},{"ruleId":"125","severity":1,"message":"126","line":717,"column":27,"nodeType":"127","messageId":"128","endLine":717,"endColumn":29},{"ruleId":"125","severity":1,"message":"132","line":894,"column":36,"nodeType":"127","messageId":"128","endLine":894,"endColumn":38},{"ruleId":"125","severity":1,"message":"132","line":939,"column":36,"nodeType":"127","messageId":"128","endLine":939,"endColumn":38},{"ruleId":"125","severity":1,"message":"132","line":1078,"column":36,"nodeType":"127","messageId":"128","endLine":1078,"endColumn":38},{"ruleId":"125","severity":1,"message":"132","line":1222,"column":36,"nodeType":"127","messageId":"128","endLine":1222,"endColumn":38},{"ruleId":"115","severity":1,"message":"153","line":1,"column":17,"nodeType":"117","messageId":"118","endLine":1,"endColumn":25},{"ruleId":"115","severity":1,"message":"154","line":1,"column":27,"nodeType":"117","messageId":"118","endLine":1,"endColumn":36},{"ruleId":"121","severity":2,"message":"155","line":21,"column":6,"nodeType":"123","endLine":21,"endColumn":15},{"ruleId":"121","severity":2,"message":"156","line":22,"column":8,"nodeType":"123","endLine":22,"endColumn":14},{"ruleId":"121","severity":2,"message":"157","line":23,"column":10,"nodeType":"123","endLine":23,"endColumn":20},"no-unused-vars","'Value' is defined but never used.","Identifier","unusedVar","'Field' is defined but never used.","'Shadow' is defined but never used.","react/jsx-no-undef","'Header' is not defined.","JSXIdentifier","'NameType' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'comment' is already defined.","redeclared","Expected '!==' and instead saw '!='.","'vars' is assigned a value but never used.","no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","'functionName' is already defined.","no-native-reassign",["158"],"no-negated-in-lhs",["159"],"no-use-before-define","'newName' was used before it was defined.","usedBeforeDefined","'useState' is defined but never used.","'useEffect' is defined but never used.","'Container' is not defined.","'AppBar' is not defined.","'Typography' is not defined.","no-global-assign","no-unsafe-negation"]